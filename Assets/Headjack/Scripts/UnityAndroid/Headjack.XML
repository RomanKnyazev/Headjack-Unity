<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Headjack</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:Headjack.App" -->
        <member name="F:Headjack.App.AppId">
            <summary>
            App ID
            </summary>
        </member>
        <member name="F:Headjack.App.AnalyticsManager">
            <summary>
            Analytics Object
            </summary>
        </member>
        <member name="F:Headjack.App.DataObject">
            <summary>
            Data Object
            </summary>
        </member>
        <member name="F:Headjack.App.Videosphere">
            <summary>
            The Mesh for the video player
            </summary>
        </member>
        <member name="F:Headjack.App.Downloader">
            <summary>
            The download manager
            </summary>
        </member>
        <member name="F:Headjack.App.Data">
            <summary>
            json data
            </summary>
        </member>
        <member name="M:Headjack.App.GetMediaUrl(System.String)">
            <summary>
            Url for media file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetMediaPath(System.String)">
            <summary>
            Local path for media file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoStream(System.String,System.Boolean)">
            <summary>
            stream url for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoPath(System.String)">
            <summary>
            Local path for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoUrl(System.String)">
            <summary>
            Url for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetVideoSize(System.String)">
            <summary>
            Size for video file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetJsonUrl(System.String)">
            <summary>
            Url for json file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GetJsonPath(System.String)">
            <summary>
            Local path for json file "Id"
            </summary>
        </member>
        <member name="M:Headjack.App.GotMediaFile(System.String)">
            <summary>
            Check if a Media file is already downloaded
            </summary>
        </member>
        <member name="M:Headjack.App.GotVideoFile(System.String)">
            <summary>
            Check if a Video file is already downloaded
            </summary>
        </member>
        <member name="M:Headjack.App.UpdateAvailableMedia(System.String)">
            <summary>
            Check if an update is available for media with given id
            </summary>
        </member>
        <member name="M:Headjack.App.UpdateAvailableVideo(System.String)">
            <summary>
            Check if an update is available for video with given id
            </summary>
        </member>
        <member name="M:Headjack.App.GetProjectVideoIdList(System.String)">
            <summary>
            Returns a string[] of all videos in a project
            </summary>
        </member>
        <member name="M:Headjack.App.GetProjectMediaIdList(System.String)">
            <summary>
            Returns a string[] of all media in a project
            </summary>
        </member>
        <member name="M:Headjack.App.CreateVideoSphere">
            <summary>
            Delete all files in given project number
            </summary>
        </member>
        <member name="M:Headjack.App.CreateVideoplayer">
            <summary>
            Create Videoplayer
            </summary>
        </member>
        <member name="M:Headjack.App.Initialize(Headjack.OnEnd,System.Boolean,System.Boolean)">
                   @summary Initialize the app and download necessary data
                   <param name="OnReady">Will be called when done</param>
                   <param name="autoCreateCamera">Also activate the VR camera</param>
                   <param name="cardboardStereoMode">(cardboard) VR Mode enabled for cardboard</param>
                   @note Must be called before all other Headjack operations
                   <example> 
                   <b>Example</b>
                   <code>
                   public void Initialize()
                   {
                       App.Initialize(OnReady);
                   }
            
                   public void OnReady(bool Succes)
                   {
                       if (Succes)
                       {
                           print("Initialized!");
                       }else
                       {
                           print("No internet connection");
                       }
                   }
                   </code>
                   </example>
        </member>
        <member name="M:Headjack.App.DownloadAllTextures(Headjack.OnEnd,System.Boolean)">
                    <summary>
                    Download and import all textures
                    </summary>
                    <param name="OnLoaded">Will be called when done</param>
                    @note Will only download textures once, or when they are updated on the server
                    <example> 
                    <b>Example</b>
                    <code>
                        public void LoadTextures()
                        {
                            App.LoadAllTextures(OnReady);
                        }
            
                        public void OnReady(bool Succes)
                        {
                            if (Succes)
                            {
                                print("Got all textures!");
                            }else
                            {
                                print("Could not download the textures");
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.DownLoadSingleTexture(System.String,Headjack.OnEnd,System.Boolean,System.Boolean)">
                    <summary>
                    Download and import a texture
                    </summary>
                    <param name="MediaId">The media id of the texture file</param>
                    <param name="OnLoaded">Will be called when done</param>
                    @note Will only download the texture once, or when it is updated on the server
                    <example> 
                    <b>Example</b>
                    <code>
                        public void DownLoadSingleTexture()
                        {
                            App.LoadAllTextures("12345678",OnReady);
                        }
            
                        public void OnReady(bool Succes)
                        {
                            if (Succes)
                            {
                                print("Got the texture!");
                            }else
                            {
                                print("Could not download the texture");
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.EnableOVRPlatformMenu">
                    <summary>
                    If true, the back button on the GearVR will open the Oculus Platform Menu. You can disable this when the user goes out of the menu and in a video. 
                    </summary>
                    <returns>If the platform menu is enabled</returns>
                    @note GearVR only
                    @warning If disabled, make sure that the back button will always bring you back to the "upper menu" where it is enabled. The user must always be able to reach the Oculus platform menu by keep pressing the back button.
                    <example> 
                    <b>Example</b>
                    <code>
                        //Disable when playing a video
                        void PlayVideo(string id)
                        {
                            App.EnableOVRPlatformMenu=false;
                            App.Play(id, true, true, null);
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.camera">
            <summary>
            Camera information
            </summary>
        </member>
        <member name="F:Headjack.App.Crosshair">
            <summary>
            Crosshair
            </summary>
        </member>
        <member name="P:Headjack.App.IsPublished">
                     <summary>
                     Returns whether app has published state set in Headjack
                     </summary>
                     <returns>True if the app is set to published in Headjack (and is therefore available to use)</returns>
                     @warning If an app is set to unpublished in Headjack, the app will receive no media information, like projects, videos or thumbnails.
                      
                     <example> 
                     <b>Example</b>
                     <code>
                         // Show message to the user when app is unpublished
                         public void MessageUserUnpublished() 
                         {
                             if (!Headjack.App.IsPublished)
                             {
                                 Headjack.App.ShowMessage("This app is not published and is currently unavailable!", 5);
                             }
                         }
                     </code>
                     </example>
        </member>
        <member name="M:Headjack.App.Fade(System.Boolean,System.Single,Headjack.OnEnd)">
                    <summary>
                    Fade screen to or from black
                    </summary>
                    <param name="ToBlack">True to fade to black (fade out), false to fade from black (fade in)</param>
                    <param name="Time">Duration of the fade effect in seconds</param>
                    <param name="OnFade">Event function that gets executed when fade is completed</param>
                    @note Use this function to hide stutter, by fading to black before heavy loading
            
                    @note The parameters of OnFade (bool success, string error) are unused
            
                    <example> 
                    <b>Example</b>
                    <code>
                        UnityEngine.GameObject interface;
                        // This function fades the screen to black for 1.5 seconds and then disables the 'interface' GameObject
                        // Another function has to fade the screen back in, or the screen will remain black
                        void FadeOutInterface()
                        {
                            App.Fade(true, 1.5f, delegate (bool success, string error) {interface.SetActive(false);});
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.ShowCrosshair">
                   <summary>
                   Headjack's crosshair
                   </summary>
                   <returns>True if the crosshair is currently visible</returns>
                   <example> 
                   <b>Example</b>
                   <code>
                       public void HideCrosshair() 
                       {
                           App.ShowCrosshair=false;
                       }
                   </code>
                   </example>
        </member>
        <member name="T:Headjack.App.VRPlatform">
                    <summary>
                    VR platform that Headjack is running on
                    </summary>
                    @note For testing: You can change this in the Headjack settings window
        </member>
        <member name="P:Headjack.App.CurrentPlatform">
                   <summary>
                   Checks the current platform
                   </summary>
                   <returns>The current platform Headjack is running on</returns>
                   @note For testing: You can change this in the Headjack settings window
                   <example> 
                   <b>Example</b>
                   <code>
                       void LogCurrentPlatform
                       {
                           #if UNITY_ANDROID
                           if (App.CurrentPlatform == App.VRPlatform.Oculus)
                           {
                               Debug.Log("This app is running on GearVR");
                           }
                           if (App.CurrentPlatform == App.VRPlatform.Cardboard)
                           {
                               Debug.Log("This app is running on Android Cardboard");
                           }
                           #endif
            
                           #if UNITY_IOS
                           if (App.CurrentPlatform == App.VRPlatform.Cardboard)
                           {
                               Debug.Log("This app is running on Ios Cardboard");
                           }
                           #endif
            
                           #if UNITY_STANDALONE
                           if (App.CurrentPlatform == App.VRPlatform.Oculus)
                           {
                               Debug.Log("This app is running on Oculus Rift");
                           }
                           if (App.CurrentPlatform == App.VRPlatform.OpenVR)
                           {
                               Debug.Log("This app is running on HTC Vive");
                           }
                           #endif
                       }
                   </code>
                   </example>
        </member>
        <member name="T:Headjack.App.RaycastSource">
                     <summary>
                     Where the raycast is coming from
                     </summary>
                     @note MotionController will currently only work in HTC Vive Builds
        </member>
        <member name="F:Headjack.App.CrosshairHit">
                    <summary>
            		All raycast information about what the user is looking at
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being looked at
                    <example> 
                    <b>Example</b>
                    <code>
                        public float DistanceToObjectLookingAt
                        {
                            return App.CrosshairHit.distance;
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.LaserHit">
                    <summary>
            		All raycast information about what the user is pointing at with the motion controller
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being aimed at
                    <example> 
                    <b>Example</b>
                    <code>
                        public Vector3 AimingLocation
                        {
                            return App.LaserHit.point;
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.TouchHit">
                    <summary>
            		All raycast information about what the user is touching on screen (Cardboard)
                    </summary>
                    <returns>RaycastHit information</returns>
                    @note Use <see cref="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)"/> to quickly check if an certain object is being touched
                    <example> 
                    <b>Example</b>
                    <code>
                        public GameObject ObjectTouching
                        {
                            return App.TouchHit.collider.gameObject;
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.IsCrosshairHit(UnityEngine.GameObject,UnityEngine.RaycastHit@,Headjack.App.RaycastSource)">
                    <summary>
                    Returns true if the user is looking at the target
                    </summary>
                    <param name="target">The object to check</param>
                    <param name="raycastSource">Where the raycast is coming from</param>
                    <returns>True if the user is looking at the object</returns>
                    @note Object must have a collider (2d colliders won't work)
                    <example> 
                    <b>Example</b>
                    <code>
                        bool IsTheCameraLookingAtMe
                        {
                            return App.IsCrosshairHit(gameobject);
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.IsVRMode">
                   <summary>
                   Returns whether app is currently running in VR mode (e.g. stereo display), or not (e.g. fullscreen cardboard menu)
                   </summary>
                   <returns>True if the app is currently running in VR mode</returns>
                   <example> 
                   <b>Example</b>
                   <code>
                       // Show message to the user when not in VR mode
                       public void MessageUserNotVR() 
                       {
                           if (!Headjack.App.IsVRMode)
                           {
                               Headjack.App.ShowMessage("You are currently not in VR mode", 5);
                           }
                       }
                   </code>
                   </example>
        </member>
        <member name="F:Headjack.App.CurrentVideo">
                    <summary>
                    The id of the video that is currently being played
                    </summary>
                    <returns>The id of the video that is currently being played</returns>
        </member>
        <member name="F:Headjack.App.CurrentProject">
                    <summary>
                    The id of the project that is currently being played
                    </summary>
                    <returns>The id of the project that is currently being played</returns>
        </member>
        <member name="M:Headjack.App.ShowMessage(System.String,System.Single,Headjack.OnEnd)">
                    <summary>
                    PopUp Messages for displaying a text
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                        public void SayHello()
                        {
                            App.ShowMessage("Hello world", 1f);
                        }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.App.CameraScale">
                    <summary>
                    Changing the camera scale will Shrink or Enlarge the world around you. Usefull if an interface needs to get just a little bigger or smaller
                    </summary>
                    <returns>Returns the current camera scale</returns>
                    @note Will clamp between 0.1 and 100
                    <example> 
                    <b>Example</b>
                    <code>
                        //Shrink or grow with the arrow keys
                        void Update()
                        {
                            if (Input.GetKeyDown(KeyCode.UpArrow))
                            {
                                App.CameraScale+=1;
                            }
                            if (Input.GetKeyDown(KeyCode.DownArrow))
                            {
                                App.CameraScale-=1;
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.App.CameraParent">
                    <summary>
                    VR Camera GameObject
                    </summary>
                    <returns>GameObject of the active VR Camera</returns>
                    @note For Camera Position or Rotation, please use <see cref="!:App.Camera"/>. For Disabling or Enabling the Camera, please use <see cref="M:Headjack.App.SetCamera(System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Headjack.App.SetCamera(System.Boolean,System.Boolean)">
                    <summary>
                    Enable or Disable the VR Camera. Enable or Disable cardboard VR mode
                    </summary>
                    <param name="visible">Enable or Disable the VR Camera</param>
                    <param name="vrMode">(cardboard) Enable or Disable VR mode</param>
                    <example> 
                    <b>Example</b>
                    <code>
                        public void GoFullScreen()
                        {
                            App.SetCamera(true,false);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.SetCameraBackground(UnityEngine.Color)">
                    <summary>
                    Set background color
                    </summary>
                    <param name="backgroundColor"><see cref="T:UnityEngine.Color"/> object containing new background color</param>
                    @note This sets the background color of the active VR camera, and persists between Unity scenes.
            
                    <example> 
                    <b>Example</b>
                    <code>
                        // Set backgound color to red
                        public void SetRedBackground()
                        {
                            Headjack.App.SetCameraBackground(Color.red);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Recenter">
                    <summary>
                    Recenter orientation and position on your device
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Recenter when playing a video
                    void PlayVideo(string id)
                    {
                        App.Recenter();
                        App.Play(id, true, true, null);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetTitle(System.String)">
                    <summary>
                    Get the title of the given project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <returns>The title of the project with ProjectId</returns>
                    @note To get a list with available projects, use <see cref="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                        public string GetFirstTitle()
                        {
                            string[] ids = App.GetProjects();
                            return App.GetTitle(ids[0]);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetDescription(System.String)">
                    <summary>
                    Get the Description of the given project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <returns>The description of the project with ProjectId, null if the project has no description</returns>
                    @note To get a list with available projects, use <see cref="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)"/>
                    @warning When using this, make sure to check if the string is not null before using to avoid NullReference errors
                    <example> 
                    <b>Example</b>
                    <code>
                        public string GetFirstDescription()
                        {
                            string[] ids = App.GetProjects();
                            return App.GetTitle(ids[0]);
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetProjects(System.String,System.Int32,System.Int32)">
                    <summary>
                    Contains all available projects from the server
                    </summary>
                    <param name="CategoryId">Only return projects that fit in this category filter</param>
                    <param name="MaxPageSize">Only return a part from the list</param>
                    <param name="CurrentPage">The part of the list to return. Starting at 0</param>
                    <returns>A list with project ids</returns>
                    @note Use <see cref="!:App.GetCategoryList"/> To get all available categories.
                    <example> 
                    <b>Example</b>
                    <code>
                        //In this case, 5 projects per page
                        public string[] WhatsOnTheFirstPage
                        {
                            return App.GetProjects(null,5,0);
                        }
            
                        public string[] WhatsOnTheLastPage
                        {
                            return App.GetProjects(null,5,int.MaxValue);
                        }
                    </code>
                    </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetImage(System.String,System.Boolean)" -->
        <member name="M:Headjack.App.GetAdditionalMedia">
                   <summary>
                   Get IDs of extra media items from server
                   </summary>
                   <returns>List of ID strings of extra media items as entered on Headjack "Edit app" page</returns>
                   @note Download a media item from this list using <see cref="M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)"/>
                   @note Load the downloaded media as texture using <see cref="!:App.LoadSingleTexture(string, OnEnd)"/>
                   @note Get metadata for media item using <see cref="M:Headjack.App.GetMediaMetadata(System.String)"/>
                   <example> 
                   <b>Example</b>
                   <code>
                       // return number of extra media items
                       public int GetNumberOfExtraMedia()
                       {
                           return App.GetAdditionalMedia().Count;
                       }
                   </code>
                   </example>
        </member>
        <member name="M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)">
                    <summary>
                    Download a single media item (e.g. extra media)
                    </summary>
                    <param name="mediaId">ID of media item that will be downloaded</param>
                    <param name="wifiOnly">Set to true to only download over wifi and not use mobile data</param>
                    <param name="onEnd">This delegate is called when the download has finished (or failed)</param>
                    @note mediaId must be a media item either in extra media or a thumbnail of a project or category used in the app
                    @note Videos in projects are special entries on the server and do not have a media ID
                    @note onEnd returned bool indicates success of download, string contains error message of success is false
                    <example> 
                    <b>Example</b>
                    <code>
                        // download first extra media item (over wifi only)
                        public void DownloadFirstExtraMedia()
                        {
                            if (App.GetAdditionalMedia().Count > 0)
                            {
                                App.DownloadSingleMedia(App.GetAdditionalMedia()[0], true, 
                                    delegate (bool success, string error) 
                                    {
                                        if (success) 
                                        {
                                            Debug.Log("Downloaded first extra media item");
                                        }
                                        else
                                        {
                                            Debug.LogError("Downloading first extra media item failed!");
                                        }
                                    });
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.App.AppMetadata">
                    <summary>
                    Container class for app metadata, used by <see cref="M:Headjack.App.GetAppMetadata"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.Published">
                        <summary>
                        True if the loaded application is published
                        </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.ProductName">
                        <summary>
                        The application's name
                        </summary>
        </member>
        <member name="F:Headjack.App.AppMetadata.CompanyName">
                        <summary>
                        Company name
                        </summary>
        </member>
        <member name="M:Headjack.App.GetAppMetadata">
                   <summary>
                   Get metadata for the app
                   </summary>
                   <returns><see cref="T:Headjack.App.AppMetadata"/>class containing metadata for App</returns>
                   <example> 
                   <b>Example</b>
                   <code>
                       bool IsMyAppPublished()
                       {
                           return Headjack.App.GetAppMetadata().Published;               
                       }
                   </code>
                   </example>
        </member>
        <member name="T:Headjack.App.VideoMetadata">
                    <summary>
                    Container class for video metadata, used by <see cref="M:Headjack.App.GetVideoMetadata(System.String)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.id">
                        <summary>
                        Unique ID of the video, differs from projectId
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.StereoScopic">
                        <summary>
                        True when video is stereoscopic, false when video is monoscopic
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Duration">
                        <summary>
                        Duration of the video in milliseconds
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Width">
                        <summary>
                        The video's dimensions
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.Height">
                        <summary>
                        The video's dimensions
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.DurationMMSS">
                        <summary>
                        Formatted string of video duration
                        </summary>
        </member>
        <member name="F:Headjack.App.VideoMetadata.DurationHHMMSS">
                        <summary>
                        Formatted string of video duration
                        </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetVideoMetadata(System.String)" -->
        <member name="T:Headjack.App.MediaMetadata">
                    <summary>
                    Container class with metadata about a media item (project thumbnail, extra media item)
                    </summary>
                    @note Get media metadata using function <see cref="M:Headjack.App.GetMediaMetadata(System.String)"/>
                    @note Some metadata fields are only relevant to particular media items (e.g. <see cref="!:App.MediaData.Width"/> for images)
        </member>
        <member name="F:Headjack.App.MediaMetadata.Id">
                        <summary>
                        Media ID of the item that this metadata describes
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.MimeType">
                        <summary>
                        MIME type of this media item (e.g. "image/png")
                        @note certain media items do not have an official MIME type, so they get an unofficial type (e.g. "audio/x-tbe" for a TBE spatial audio file)
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Filename">
                        <summary>
                        Filename of the media item when downloaded (e.g. using <see cref="M:Headjack.App.DownloadSingleMedia(System.String,System.Boolean,Headjack.OnEnd)"/>)
                        @note This is a randomly generated filename and not the original name shown on the Headjack website
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Width">
                        <summary>
                        Width (in pixels) of media item, for image files
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.Height">
                        <summary>
                        Height (in pixels) of media item, for image files
                        </summary>
        </member>
        <member name="F:Headjack.App.MediaMetadata.FileSize">
                        <summary>
                        Filesize (in bytes) of media item
                        </summary>
        </member>
        <member name="M:Headjack.App.GetMediaMetadata(System.String)">
                    <summary>
                    Get metadata for media item
                    </summary>
                    <param name="mediaId">ID of media item</param>
                    <returns><see cref="!:App.MediaData"/> class containing metadata for media item, or null when invalid mediaId</returns>
                    @note mediaId must be a media item either in extra media or a thumbnail of a project or category used in the app 
                    @note Videos in projects are special entries on the server and do not have a media ID
                    <example> 
                    <b>Example</b>
                    <code>
                        // return filesize of first png image in extra media list (or -1 if no png image in list)
                        public long GetFirstPNGSize()
                        {
                            for (int i = 0; i &lt; App.GetAdditionalMedia().Count; ++i)
                            {
                                App.MediaData currentMediaData = App.GetMediaMetadata(App.GetAdditionalMedia()[i]);
                                if (currentMediaData.MimeType == "image/png")
                                {
                                    return currentMediaData.FileSize;
                                }
                            }
                            return -1;
                        }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.App.CategoryMetadata">
                    <summary>
                    Container class for Category metadata, used by <see cref="!:App.GetCategoryMetadata(string categoryId)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Id">
                        <summary>
                        Id of this category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Name">
                        <summary>
                        Name of the Category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.Description">
                        <summary>
                        Additional description of the category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.ThumbnailId">
                        <summary>
                        Media ID of the thumbnail associated with this category
                        </summary>
        </member>
        <member name="F:Headjack.App.CategoryMetadata.ParentId">
                        <summary>
                        This category's parent category (null if this is not a sub-category)
                        </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetCategoryMetadata(System.String)" -->
        <member name="T:Headjack.App.ProjectMetadata">
                   <summary>
                   Container class with metadata about a Project
                   </summary>
                   @note Get Project metadata using function <see cref="!:App.GetProjectMetadata(string)"/>
                   @note Certain fields can be null when they arent uploaded on the server
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Id">
                        <summary>
                        Id of the project
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Title">
                        <summary>
                        The project's title
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Description">
                        <summary>
                        The project's description (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.Category">
                        <summary>   
                        The category where the project can be found (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.ThumbnailId">
                        <summary>
                        The media id of the thumbnail that belongs to this project (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.VideoId">
                        <summary>
                        The video that is included in the project (can be null)
                        </summary>
        </member>
        <member name="F:Headjack.App.ProjectMetadata.TotalSize">
                        <summary>
                        Filesize (in <see cref="T:Headjack.App.ByteConversionType"/>) of all files in this project, when downloaded on current device
                        </summary>
        </member>
        <member name="T:Headjack.App.ByteConversionType">
                    <summary>
                    Order of magnitude of filesizes, used by <see cref="M:Headjack.App.GetProjectMetadata(System.String,Headjack.App.ByteConversionType)"/>.
                    </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Headjack.App.GetProjectMetadata(System.String,Headjack.App.ByteConversionType)" -->
        <member name="M:Headjack.App.GetCategories">
                    <summary>
                    Containts all category ids
                    </summary>
                    <returns>a string array containing all category ids</returns>
        </member>
        <member name="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)">
                    <summary>
                    Play a project
                    </summary>
                    <param name="ProjectId">The project you want to play</param>
                    <param name="Stream">Directly stream the video from the server</param>
                    <param name="WifiOnly">(Streaming) only stream when connected to a wifi network</param>
                    <param name="onEnd">Will be called when the video is finished</param>
                    @note Will automatically create and initialize the video player. If stream is false, the video won't play if it isn't downloaded first
                    @warning WifiOnly is strongly recommended when using Stream to avoid high mobile data costs
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StreamFirstVideo()
                    {
                        string id = App.GetProjects()[0];
                        App.Play(id, true, true, onEnd);
                    }
            
                    public void onEnd(bool succes, string error)
                    {
                        print("Video has finished playing!");
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.DestroyVideoPlayer">
                    <summary>
                    Destroys the active videoplayer
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    GameObject menuObject;
                    public void BackToMenu()
                    {
                       App.DestroyVideoPlayer();
                       menuObject.SetActive(true);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Download(System.String,System.Boolean,Headjack.OnEnd)">
                     <summary>
                     Download all files in a project
                     </summary>
                     <param name="ProjectId">The project you want to download</param>
                     <param name="WifiOnly">Only download when connected to internet</param>
                     <param name="onEnd">Will be called when the download is finished</param>
                     @note Will call onEnd with (false,"NoWifi") if WifiOnly is true and there is no wifi connection
                     <example> 
                     <b>Example</b>
                     <code>
                     public string id;
                     public void DownloadAndPlayFirstVideo()
                     {
                         id = App.GetProjects()[0];
                         App.Download(id, true, OnDownloaded);
                     }
                     public void OnDownloaded(bool succes, string error)
                     {
                         if (succes)
                         {
                             App.Play(id, false, false, null);
                         }
                     }
                     </code>
                     </example>
        </member>
        <member name="M:Headjack.App.Cancel(System.String)">
                    <summary>
                    Cancel an active download
                    </summary>
                    <param name="ProjectId">Project download to cancel</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CancelAllDownloads()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            App.Cancel(project);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.Delete(System.String)">
                    <summary>
                    Delete all local files of a project
                    </summary>
                    <param name="ProjectId">The project id</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void DeleteAllProjects()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            App.Delete(project);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GotFiles(System.String)">
                    <summary>
                    Check if you have all the files of a project
                    </summary>
                    <param name="ProjectId">Project to check</param>
                    <returns>True if you have all the files</returns>
                    @note Does not check if you have the latest version of the files, for that see <see cref="M:Headjack.App.UpdateAvailable(System.String)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StreamOnlyWhenFilesAreNotPresent(string projectid)
                    {
                        if (App.GotFiles(projectid))
                        {
                            App.Play(projectid, false, false, null);
                        }
                        else
                        {
                            App.Play(projectid, true, true, null);
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.UpdateAvailable(System.String)">
                    <summary>
                    Check if a project or media file has an update available
                    </summary>
                    <param name="Id">Id to check</param>
                    <returns>True if there is an update available</returns>
                    @note Will also return True if the files are not yet downloaded!!
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CheckForUpdates()
                    {
                        string[] projects = App.GetProjects();
                        foreach (string project in projects)
                        {
                            if(App.UpdateAvailable(project))
                            {
                                print(project + " has an update available!");
                            }
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.ProjectIsLiveStream(System.String)">
                    <summary>
                    Check if a project contains a live stream
                    </summary>
                    <returns>true if the project contains a live stream</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                        public string IsLivestream(ProjectId)
                        {
                            if(App.ProjectIsLiveStream(ProjectId))
                            {
                                return "Livestream!";
                            }else{
                                return "No Livestream";
                            }
                        }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetCustomVariable(System.String)">
                    <summary>
                    Access custom template variables, downloaded from Headjack
                    </summary>
                    <returns>Returns the string value corresponding to the custom variable key, or null of key does not exist</returns>
                    <param name="key">String key/name identifying the custom variable</param>
                    <example> 
                    <b>Example</b>
                    <code>
                    // Get a Texture object of an additional media item, whose id is passed to this
                    // template using a custom variable called "menu_background_image_id"
                    public Texture2D getBackgroundTexture()
                    {
                        return App.GetImage(App.GetCustomVariable("menu_background_image_id"));
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetColor(System.String,UnityEngine.Color)">
                    <summary>
                    Get the app colors, from the server
                    </summary>
                    <returns>Returns the color given in Key</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public Color GetBackgroundColor(string key)
                    {
                        return App.GetColor(key,Color.black);
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.ProjectIsDownloading(System.String)">
                    <summary>
                    Check if a project is currently downloading
                    </summary>
                    <param name="ProjectId">Project to check</param>
                    <returns>True if a project is currently downloading</returns>
                    @note To get the progress, use <see cref="M:Headjack.App.GetProjectProgress(System.String)"/>
                    <example> 
                    <b>Example</b>
                    <code>
                    public float GetProgress(string projectid)
                    {
                        if (App.ProjectIsDownloading(projectid))
                        {
                            return App.GetProjectProgress(projectid);
                        }
                        else
                        {
                            return -1;
                        }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.App.GetProjectProgress(System.String)">
                    <summary>
                    Get the download progress of a project (0 to 100)
                    </summary>
                    <param name="ProjectId">The project to check</param>
                    <returns>The download progress from 0 to 100, -1 on fail</returns>
                    @note The returned value is not rounded, for displaying smooth loading bars
                    <example> 
                    <b>Example</b>
                    <code>
                    public string GetProgressText(string projectid)
                    {
                        if(!App.ProjectIsDownloading(projectid))
                        {
                            return null;
                        }
                        float progress = App.GetProjectProgress(projectid);
                        return Mathf.FloorToInt(progress).ToString() + "%";
                    }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.VideoPlayer.AudioConfig">
                    <summary>
                    Description of which audio tracks are playing, audio track in video file (internal) and/or external spatial audio file.
                    Get the current audio configuration using <see cref="M:Headjack.VideoPlayer.GetAudioConfig"/>, set the audio configuration using <see cref="M:Headjack.VideoPlayer.SetAudioConfig(System.Boolean,System.Boolean)"/>.
                    </summary>
        </member>
        <member name="F:Headjack.VideoPlayer.AudioConfig.Internal">
                        <summary>
                        Describes whether the audiotrack embedded in the video file is enabled
                        </summary>
        </member>
        <member name="F:Headjack.VideoPlayer.AudioConfig.External">
                        <summary>
                        Describes whether the audiotrack embedded in the video file is enabled
                        </summary>
        </member>
        <member name="T:Headjack.VideoPlayer.Status">
            		<summary>
            		Status codes of videoplayer returned by GetStatus()
            		</summary>
        </member>
        <member name="F:Headjack.VideoPlayer.Eyes">
                    <summary>
                    Left and Right Eye are accessible
                    </summary>
                    <returns>GameObject[2] with Left in 0 and Right in 1</returns>
        </member>
        <member name="P:Headjack.VideoPlayer.Buffering">
                    <summary>
                    True if the videoplayer is buffering
                    </summary>
                    <returns>If the videoplayer is buffering</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Show buffering icon when buffering
                    void Update()
                    {
                    if(App.Player.Buffering)
                    {
            	        BufferingObject.SetActive(true);
                    }else{
            	        BufferingObject.SetActive(false);
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.Volume">
                    <summary>
                    Videoplayer volume
                    </summary>
                    <returns>The current volume of the videoplayer</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change volume with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.UpArrow))
                    {
                        App.Player.Volume += 0.1f;
                        }
                    if (Input.GetKeyDown(KeyCode.DownArrow))
                    {
                        App.Player.Volume -= 0.1f;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.Seek">
                    <summary>
                    The video position (0.0 - 1.0)
                    </summary>
                    <returns>The current position of the video from 0.0 to 1.0</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change position with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.RightArrow))
                    {
                        App.Player.Seek += 0.05f;
                        }
                    if (Input.GetKeyDown(KeyCode.LeftArrow))
                    {
                        App.Player.Seek -= 0.05f;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.SeekMs">
                    <summary>
                    The video position in milliseconds
                    </summary>
                    <returns>The current position of the video in milliseconds</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    //Change position by 5 seconds with Arrow Keys
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.RightArrow))
                    {
                        App.Player.SeekMs += 5000;
                        }
                    if (Input.GetKeyDown(KeyCode.LeftArrow))
                    {
                        App.Player.SeekMs -= 5000;
                    }
                    }   
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.Loop">
                    <summary>
                    If this is a looping video
                    </summary>
                    <returns>If the video is currently set to loop</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void LoopButtonSwitch()
                    {
                    App.Player.Loop=!App.Player.Loop;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.Mute">
                    <summary>
                    If this video is muted
                    </summary>
                    <returns>If the video is currently muted</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void MuteButtonSwitch()
                    {
                    App.Player.Mute=!App.Player.Mute;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.Duration">
                    <summary>
                    The total duration of the video
                    </summary>
                    <returns>The total duration of the video in milliseconds</returns>
                    <example> 
                    <b>Example</b>
                    <code>
                    public float VideoLengthInSeconds()
                    {
                        return App.Player.Duration*0.001f;
                    }
                    </code>
                    </example>
        </member>
        <member name="P:Headjack.VideoPlayer.IsPlaying">
                    <summary>
                    If the video is being played right now
                    </summary>
                    <returns>True if the video is being played right now</returns>
                    @note False on pause
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    //Don't show the crosshair if the video is playing
                    if(App.Player.IsPlaying)
                    {
                        App.ShowCrosshair=false;
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.SetAudioConfig(System.Boolean,System.Boolean)">
            		<summary>
            		Sets audio configuration, whether to play audio of video file and whether to play external (spatial) audio file
            		</summary>
            		<param name="internalAudio">set to true to enable video audio track</param>
            		<param name="externalAudio">set to true to enable external (spatial) audio track</param>
            		@note enabling both internal and external audio causes both tracks to play simultaneously
            
            		@note enabling the external audio track without an external audio file being present in the project has no effect
        </member>
        <member name="M:Headjack.VideoPlayer.GetAudioConfig">
                    <summary>
                    Gets the audio playing configuration, whether playing audio of video file (internal) and/or playing external (spatial) audio file (external)
                    </summary>
                    <returns><see cref="T:Headjack.VideoPlayer.AudioConfig"/> struct describing current audio configuration</returns>
                    @note use <see cref="M:Headjack.VideoPlayer.SetAudioConfig(System.Boolean,System.Boolean)"/> to change the audio configuration
        </member>
        <member name="M:Headjack.VideoPlayer.Play(System.String,Headjack.OnEnd,System.String)">
                    <summary>
                    Play a new video
                    </summary>
                    <param name="FullPath">Full path to the mp4 file</param>
                    <param name="onEnd">Will be called when the video is finished</param>
                    @note onEnd overwrites current onEnd
                    @warning You need a full path to the mp4 file. To play videos from the server use <see cref="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)"/>
        </member>
        <member name="M:Headjack.VideoPlayer.Pause">
                    <summary>
                    Pause the video
                    </summary>
                    @note Will set VideoPlayer.IsPlaying to false
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.Pause();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.Resume">
                    <summary>
                    Resume the video
                    </summary>
                    @note Will set VideoPlayer.IsPlaying to true
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.Resume();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.PauseResume">
                    <summary>
                    Switch between playing and paused
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    void Update()
                    {
                    //Pause switch
                    if (Input.GetKeyDown(KeyCode.Space))
                    {
                        App.Player.PauseResume();
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.Clean">
                    <summary>
                    Clean up the video
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void Release()
                    {
                    App.Player.Clean();
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.Stop">
                    <summary>
                    Stop the video
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void StopVideo()
                    {
                    App.Player.Stop();
                    }
                    </code>
                    </example>
        </member>
        <member name="M:Headjack.VideoPlayer.SetEyes(System.Boolean,System.Boolean)">
                    <summary>
                    Stereoscopic settings
                    </summary>
                    <param name="InputIsStereo">Is the video stereoscopic</param>
                    <param name="OutputIsStereo">Display in stereoscopic</param>
                    @warning This will be automatically set with <see cref="M:Headjack.App.Play(System.String,System.Boolean,System.Boolean,Headjack.OnEnd)"/>. Use <see cref="M:Headjack.VideoPlayer.SetStereoscopicRendering(System.Boolean)"/> to switch enable/disable the stereoscopic rendering
        </member>
        <member name="M:Headjack.VideoPlayer.SetStereoscopicRendering(System.Boolean)">
                    <summary>
                    Stereoscopic video rendering
                    </summary>
                    <param name="Stereoscopic">Render stereoscopic</param>
                    @note You can use this to disable the stereo effect if you want to display an interface
                    <example> 
                    <b>Example</b>
                    <code>
                    public void SwitchToMono()
                    {
                    App.Player.SetStereoscopicRendering(false);
                    }
                    </code>
                    </example>
        </member>
        <member name="T:Headjack.VRInput.VrButton">
                    <summary>
                    Button class, Confirm and Back are universal across all platforms
                    </summary>
        </member>
        <member name="F:Headjack.VRInput.Confirm">
                    <summary>
                    VR Input button
                    </summary>
                    @note Left mouse button - Space - Screen tap - Oculus Remote Confirm - Gear VR touchpad tap - Vive Trigger
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CheckIfClickedOnMe()
                    {
                    if (App.IsCrosshairHit(gameObject))
                    {
                        if (VRInput.Confirm.Pressed)
                        {
                            print("Clicked on me!");
                        }
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.Back">
                    <summary>
                    VR Back button
                    </summary>
                    @note Escape button - Android back button - Oculus Remote Return - Gear VR Back button - Vive Menu button
                    <example> 
                    <b>Example</b>
                    <code>
                    public void CheckIfClickedOnMe()
                    {
                    if (App.IsCrosshairHit(gameObject))
                    {
                        if (VRInput.Confirm.Pressed)
                        {
                            print("Clicked on me!");
                        }
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.MotionControllerLaser">
                    <summary>
                    Show the laser of the motion controller
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void ShowLaserWhenHoldingTrigger()
                    {
                       if (VRInput.Confirm.Hold)
                       {
                           VRInput.MotionControllerLaser=true;
                       }else
                       {
                           VRInput.MotionControllerLaser=false;
                       }
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Headjack.VRInput.MotionControllerShow">
                    <summary>
                    Show the motion controller, it will be glass/seethrough if false
                    </summary>
                    <example> 
                    <b>Example</b>
                    <code>
                    public void ShowControllerWhenHoldingTrigger()
                    {
                    if (VRInput.Confirm.Hold)
                    {
                        VRInput.MotionControllerShow=true;
                    }else
                    {
                        VRInput.MotionControllerShow=false;
                    }
                    }
                    </code>
                    </example>
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_HTTP_Transfer">
            Sent to indicate that more data has been read or an error occured.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Livestreaming_StatusChange">
            Indicates that the livestreaming session has been updated. You can use this
            information to throttle your game performance or increase CPU/GPU
            performance. Use Message.GetLivestreamingStatus() to extract the updated
            livestreaming status.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Matchmaking_MatchFound">
            Indicates that a match has been found, for example after calling
            Matchmaking.Enqueue(). Use Message.GetRoom() to extract the matchmaking
            room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_ConnectionStateChange">
            Indicates that a connection has been established or there's been an error.
            Use NetworkingPeer.GetState() to get the result; as above,
            NetworkingPeer.GetID() returns the ID of the peer this message is for.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PeerConnectRequest">
            Indicates that another user is attempting to establish a P2P connection
            with us. Use NetworkingPeer.GetID() to extract the ID of the peer.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PingResult">
            Generated in response to Net.Ping(). Either contains ping time in
            microseconds or indicates that there was a timeout.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_InviteAccepted">
             Indicates that the user has accepted an invitation, for example in Oculus
             Home. Use Message.GetString() to extract the ID of the room that the user
             has been inivted to as a string. Then call ovrID_FromString() to parse it
             into an ovrID.
            
             Note that you must call Room.Join() if you want to actually join the room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_RoomUpdate">
            Indicates that the current room has been updated. Use Message.GetRoom() to
            extract the updated room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_ConnectRequest">
            Sent when another user is attempting to establish a VoIP connection. Use
            Message.GetNetworkingPeer() to extract information about the user, and
            Voip.Accept() to accept the connection.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_StateChange">
            Sent to indicate that the state of the VoIP connection changed. Use
            Message.GetNetworkingPeer() and NetworkingPeer.GetState() to extract the
            current state.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_SystemVoipState">
             Sent to indicate that some part of the overall state of SystemVoip has
             changed. Use Message.GetSystemVoipState() and the properties of
             SystemVoipState to extract the state that triggered the notification.
            
             Note that the state may have changed further since the notification was
             generated, and that you may call the `GetSystemVoip...()` family of
             functions at any time to get the current state directly.
        </member>
        <member name="M:Oculus.Platform.Packet.ReadBytes(System.Byte[])">
            Copies all the bytes in the payload into byte[] destination.  ex:
              Package package ...
              byte[] destination = new byte[package.Size];
              package.ReadBytes(destination);
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Connected">
            Connection to the peer is established.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Timeout">
            A timeout expired while attempting to (re)establish a connection. This can
            happen if peer is unreachable or rejected the connection.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Closed">
            Connection to the peer is closed. A connection transitions into this state
            when it is explicitly closed by either the local or remote peer calling
            Net.Close(). It also enters this state if the remote peer no longer
            responds to our keep-alive probes.
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate(Oculus.Platform.RoomJoinPolicy,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateAndJoinPrivate2.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate2(Oculus.Platform.RoomJoinPolicy,System.UInt32,Oculus.Platform.RoomOptions)">
             Creates a new private (client controlled) room and adds the caller to it.
             This type of room is good for matches where the user wants to play with
             friends, as they're primarially discoverable by examining which rooms your
             friends are in.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param roomOptions Additional room configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Get(System.UInt64)">
             Allows arbitrary rooms for the application to be loaded.
             \param roomID The room to load.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrent">
             Easy loading of the room you're currently in. If you don't want live
             updates on your current room (by using subscribeToUpdates), you can use
             this to refresh the data.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrentForUser(System.UInt64)">
             Allows the current room for a given user to be loaded. Remember that the
             user's privacy settings may not allow their room to be loaded. Because of
             this, it's often possible to load the users in a room, but not to take
             those users and load their room.
             \param userID ID of the user for which to load the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers">
             Loads a list of users you can invite to your current room. These are pulled
             from your friends list and filtered for relevance and interest. If your
             current room cannot be joined, this list will be empty.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers2(Oculus.Platform.RoomOptions)">
             Loads a list of users you can invite to your current room. These are pulled
             from your friends list and filtered for relevance and interest. If your
             current room cannot be joined, this list will be empty.
             \param roomOptions Additional configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetModeratedRooms">
             Fetches the list of moderated rooms created for the application.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.InviteUser(System.UInt64,System.String)">
             Invites a user to the specified room.
             \param roomID The ID of your current room.
             \param inviteToken A user's invite token, returned by Room.GetInvitableUsers().
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join(System.UInt64,System.Boolean)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join2(System.UInt64,Oculus.Platform.RoomOptions)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param roomOptions Additional room configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.KickUser(System.UInt64,System.UInt64,System.Int32)">
             Allows the room owner to kick a user out of the current room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param userID The user to be kicked (cannot be yourself).
             \param kickDurationSeconds Length of the ban, in seconds.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.LaunchInvitableUserFlow(System.UInt64)">
             Launch the invitable user flow to invite to the logged in user's current
             room. This is intended to be a nice shortcut for developers not wanting to
             build out their own Invite UI although it has the same rules as if you
             build it yourself.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Leave(System.UInt64)">
             Removes you from your current room. Returns the solo room you are now in if
             it succeeds
             \param roomID The room you're currently in.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetDescription(System.UInt64,System.String)">
             Allows the room owner to set the description of their room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param description The new name of the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateMembershipLockStatus(System.UInt64,Oculus.Platform.RoomMembershipLockStatus)">
             Disallow new members from being able to join the room. This will prevent
             joins from Room.Join(), invites, 'Join From Home', etc. Users that are in
             the room at the time of lockdown WILL be able to rejoin.
             \param roomID The room whose membership you want to lock or unlock.
             \param membershipLockStatus The new LockStatus for the room
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateOwner(System.UInt64,System.UInt64)">
             Allows the room owner to transfer ownership to someone else.
             \param roomID The room that the user owns (check Room.GetOwner()).
             \param userID The new user to make an owner; the user must be in the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdatePrivateRoomJoinPolicy(System.UInt64,Oculus.Platform.RoomJoinPolicy)">
             Sets the join policy of the user's private room.
             \param roomID The room ID that the user owns (check Room.GetOwner()).
             \param newJoinPolicy The new join policy for the room.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.GetStatus">
             Return the status of the current livestreaming session if there is one.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.PauseStream">
             Pauses the livestreaming session if there is one. Otherwise it no-ops
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.ResumeStream">
             Resumes the livestreaming session if one is running. Otherwise it no-ops.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Browse2.
             \param pool A BROWSE type matchmaking pool.
             \param customQueryData Optional. Custom query data.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE
            
             See overview documentation above.
            
             Return a list of matchmaking rooms in the current pool filtered by skill
             and ping (if enabled). This also enqueues the user in the matchmaking
             queue. When the user has made a selection, call Matchmaking.JoinRoom() on
             one of the rooms that was returned. If the user stops browsing, call
             Matchmaking.Cancel().
            
             In addition to the list of rooms, enqueue results are also returned. Call
             MatchmakingBrowseResult.GetEnqueueResult() to obtain them. See
             OVR_MatchmakingEnqueueResult.h for details.
             \param pool A BROWSE type matchmaking pool.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel(System.String,System.String)">
             DEPRECATED. Use Cancel2.
             \param pool The pool in question.
             \param requestHash Used to find your entry in a queue.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel">
             Modes: QUICKMATCH, BROWSE
            
             Makes a best effort to cancel a previous Enqueue request before a match
             occurs. Typically triggered when a user gives up waiting. For BROWSE mode,
             call this when a user gives up looking through the room list or when the
             host of a room wants to stop receiving new users. If you don't cancel but
             the user goes offline, the user/room will be timed out of the queue within
             30 seconds.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom(System.String,System.UInt32,System.Boolean,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use CreateAndEnqueueRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when the room data changes, such as when users join or leave.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             See overview documentation above.
            
             Create a matchmaking room, join it, and enqueue it. This is the preferred
             method. But, if you do not wish to automatically enqueue the room, you can
             call CreateRoom2 instead.
            
             Visit https://developer2.oculus.com/application/[YOUR_APP_ID]/matchmaking
             to set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom(System.String,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom2. However, Oculus recommends using
             CreateAndEnqueueRoom2 instead.
            
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom. Consider using CreateAndEnqueueRoom
             instead.
            
             Visit https://developer2.oculus.com/application/[YOUR_APP_ID]/matchmaking
             to set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Enqueue2.
             \param pool The pool to enqueue in.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: QUICKMATCH
            
             See overview documentation above.
            
             Enqueue yourself to await an available matchmaking room. The platform
             returns a MessageType.Notification_Matchmaking_MatchFound message when a
             match is found. Call Matchmaking.JoinRoom() on the returned room. The
             response contains useful information to display to the user to set
             expectations for how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param pool The pool to enqueue in.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom(System.UInt64,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Please use Matchmaking.EnqueueRoom2() instead.
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param customQueryData Optional.  See the "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom2(System.UInt64,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE (for Rooms only), ROOM
            
             See the overview documentation above. Enqueue yourself to await an
             available matchmaking room. MessageType.Notification_Matchmaking_MatchFound
             gets enqueued when a match is found.
            
             The response contains useful information to display to the user to set
             expectations for how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.GetAdminSnapshot">
             Modes: QUICKMATCH, BROWSE
            
             Used to debug the state of the current matchmaking pool queue. This is not
             intended to be used in production.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.JoinRoom(System.UInt64,System.Boolean)">
             Modes: QUICKMATCH, BROWSE
            
             Joins a room returned by a previous call to Matchmaking.Enqueue() or
             Matchmaking.Browse().
             \param roomID ID of a room previously returned from MessageType.Notification_Matchmaking_MatchFound or Matchmaking.Browse().
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.StartMatch(System.UInt64)">
             Modes: QUICKMATCH, BROWSE (+ Skill Pool)
            
             For pools with skill-based matching. See overview documentation above.
            
             Call after calling Matchmaking.JoinRoom() when the players are present to
             begin a rated match for which you plan to report the results (using
             Matchmaking.ReportResultInsecure()).
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntries(System.String,System.Int32,Oculus.Platform.LeaderboardFilterType,Oculus.Platform.LeaderboardStartAt)">
             Requests a block of Leaderboard Entries.
             \param leaderboardName The name of the leaderboard whose entries to return.
             \param limit Defines the maximum number of entries to return.
             \param filter Allows you to restrict the returned values by friends.
             \param startAt Defines whether to center the query on the user or start at the top of the leaderboard.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntriesAfterRank(System.String,System.Int32,System.UInt64)">
             Requests a block of leaderboard Entries.
             \param leaderboardName The name of the leaderboard.
             \param limit The maximum number of entries to return.
             \param afterRank The position after which to start.  For example, 10 returns leaderboard results starting with the 11th user.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.WriteEntry(System.String,System.Int64,System.Byte[],System.Boolean)">
             Writes a single entry to a leaderboard.
             \param leaderboardName The leaderboard for which to write the entry.
             \param score The score to write.
             \param extraData A 2KB custom data field that is associated with the leaderboard entry. This can be a game replay or anything that provides more detail about the entry to the viewer.
             \param forceUpdate If true, the score always updates.  This happens even if it is not the user's best score.
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetSystemVoipSuppressed(System.Boolean)">
             Sets whether SystemVoip should be suppressed so that this app's Voip can
             use the mic and play incoming Voip audio.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddCount(System.String,System.UInt64)">
             Add 'count' to the achievement with the given name. This must be a COUNT
             achievement.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddFields(System.String,System.String)">
             Unlock fields of a BITFIELD acheivement.
             \param name The name of the achievement to unlock
             \param fields A string containing either '0' or '1' characters. Every '1' will unlock the field in the corresponding position.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllDefinitions">
             Request all achievement definitions for the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllProgress">
             Request the progress for the user on all achievements in the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetDefinitionsByName(System.String[])">
             Request the achievement definitions that match the specified names.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetProgressByName(System.String[])">
             Request the user's progress on the specified achievements.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.Unlock(System.String)">
             Unlock the achievement with the given name. This can be of any achievement
             type.
            
        </member>
        <member name="M:Oculus.Platform.Application.GetVersion">
             Requests version information, including the currently installed and latest
             available version name and version code.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Delete(System.String,System.String)">
             Deletes the specified save data buffer. Conflicts are handled just like
             Saves.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Load(System.String,System.String)">
             Loads the saved entry for the specified bucket and key. If a conflict
             exists with the key then an error message is returned.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadBucketMetadata(System.String)">
             Loads all the metadata for the saves in the specified bucket, including
             conflicts.
             \param bucket The name of the storage bucket.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadConflictMetadata(System.String,System.String)">
             Loads the metadata for this bucket-key combination that need to be manually
             resolved.
             \param bucket The name of the storage bucket
             \param key The key for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadHandle(System.String)">
             Loads the data specified by the storage handle.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadMetadata(System.String,System.String)">
             load the metadata for the specified key
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepLocal(System.String,System.String,System.String)">
             Selects the local save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote that the local file was resolved against.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepRemote(System.String,System.String,System.String)">
             Selects the remote save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Save(System.String,System.String,System.Byte[],System.Int64,System.String)">
             Send a save data buffer to the platform.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param data Start of the data block.
             \param counter Optional. Counter used for user data or auto-deconfliction.
             \param extraData Optional. String data that isn't used by the platform.
            
        </member>
        <member name="M:Oculus.Platform.Entitlements.IsUserEntitledToApplication">
             Returns whether the current user is entitled to the current app.
            
        </member>
        <member name="M:Oculus.Platform.IAP.ConsumePurchase(System.String)">
             Allow the consumable IAP product to be purchased again. Conceptually, this
             indicates that the item was used or consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetProductsBySKU(System.String[])">
             Retrieve a list of IAP products that can be purchased.
             \param skus The SKUs of the products to retrieve.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetViewerPurchases">
             Retrieve a list of Purchase that the Logged-In-User has made. This list
             will also contain consumable purchases that have not been consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.LaunchCheckoutFlow(System.String)">
             Launch the checkout flow to purchase the existing product. Oculus Home
             tries handle and fix as many errors as possible. Home returns the
             appropriate error message and how to resolveit, if possible. Returns a
             purchase on success, empty purchase on cancel, and an error on error.
             \param sku IAP sku for the item the user wishes to purchase.
            
        </member>
        <member name="M:Oculus.Platform.Notifications.GetRoomInviteNotifications">
             Retrieve a list of all pending room invites for your application.
            
        </member>
        <member name="M:Oculus.Platform.Notifications.MarkAsRead(System.UInt64)">
             Mark a notification as read. This causes it to disappear from the Universal
             Menu, the Oculus App, Oculus Home, and in-app retrieval.
            
        </member>
        <member name="M:Oculus.Platform.Parties.GetCurrent">
             Load the party the current user is in.
            
        </member>
        <member name="M:Oculus.Platform.Users.Get(System.UInt64)">
             Retrieve the user with the given ID. This might fail if the ID is invalid
             or the user is blocked.
            
             NOTE: Users will have a unique ID per application.
             \param userID User ID retrieved with this application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetAccessToken">
             Return an access token for this user, suitable for making REST calls
             against graph.oculus.com.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUser">
             Retrieve the currently signed in user. This call is available offline.
            
             NOTE: This will not return the user's presence as it should always be
             'online' in your application.
            
             NOTE: Users will have a unique ID per application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriends">
             Retrieve a list of the logged in user's friends.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriendsAndRooms">
             Retrieve a list of the logged in user's friends and any rooms they might be
             in.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetOrgScopedID(System.UInt64)">
             returns an ovrID which is unique per org. allows different apps within the
             same org to identify the user.
             \param userID to load the org scoped id of
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:Oculus.Platform.Users.GetUserProof" -->
        <member name="M:Oculus.Platform.Request.RunCallbacks(System.UInt32)">
            This will run callbacks on all messages that returned from the server.
            If too many message are coming back at once, then a limit can be passed in
            as an arg to limit the number of messages to run callbacks on at a time
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Unreliable">
             Sends a message using an unreliable data channel (UDP-based). No delivery
             or ordering guarantees are provided. Sending will fail unless a connection
             to the peer is already established, either via a previous call to
             Net.SendPacket() or an explicit Net.Connect().
            
             Ideally, each message should fit into a single packet. Therefore, it is
             recommended to keep them under 1200 bytes.
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Reliable">
            Messages are delivered reliably and in order. The networking layer retries
            until each message is acknowledged by the peer. Outgoing messages are
            buffered until a working connection to the peer is established.
        </member>
        <member name="T:GvrArmModel">
             The GvrArmModel is a standard interface to interact with a scene with the controller.
             It is responsible for:
             -  Determining the orientation and location of the controller.
             -  Predict the location of the shoulder, elbow, wrist, and pointer.
            
             There should only be one instance in the scene, and it should be attached
             to the GvrController.
        </member>
        <member name="T:GvrArmModelOffsets">
            This script positions and rotates the transform that it is attached to
            according to a joint in the arm model. See GvrArmModel.cs for details.
        </member>
        <member name="T:GvrBasePointer">
             Base implementation of IGvrPointer
            
             Automatically registers pointer with GvrPointerManager.
             Uses transform that this script is attached to as the pointer transform.
            
        </member>
        <member name="M:GvrBasePointer.OnInputModuleEnabled">
            Declare methods from IGvrPointer
        </member>
        <member name="T:GvrBasePointerRaycaster">
            This script provides shared functionality used by all Gvr raycasters.
        </member>
        <member name="F:GvrBasePointerRaycaster.RaycastMode.Camera">
             Default method for casting ray.
             Casts a ray from the camera through the target of the pointer.
             This is ideal for reticles that are always rendered on top.
             The object that is selected will always be the object that appears
             underneath the reticle from the perspective of the camera.
             This also prevents the reticle from appearing to "jump" when it starts/stops hitting an object.
            
             Note: This will prevent the user from pointing around an object to hit something that is out of sight.
             This isn't a problem in a typical use case.
        </member>
        <member name="F:GvrBasePointerRaycaster.RaycastMode.Direct">
            Cast a ray directly from the pointer origin.
            This is ideal for full-length laser pointers.
        </member>
        <member name="F:GvrBasePointerRaycaster.raycastMode">
            Determines which raycast mode to use for this raycaster.
        </member>
        <member name="P:GvrBasePointerRaycaster.MaxPointerDistance">
            Returns the pointer's maximum distance from the pointer's origin.
        </member>
        <member name="P:GvrBasePointerRaycaster.PointerRadius">
            Returns the pointer's radius to use for the raycast.
        </member>
        <member name="M:GvrBasePointerRaycaster.IsPointerAvailable">
            Returns true if the pointer and the pointer's transform are both
            available through the GvrPointerManager.
        </member>
        <member name="M:GvrBasePointerRaycaster.GetRay">
            Calculates the ray to use for raycasting based on
            the selected raycast mode.
        </member>
        <member name="T:GvrCameraUtils">
            Utility class that includes functions for calculating camera properties.
        </member>
        <member name="T:GvrController">
             Main entry point for the Daydream controller API.
            
             To use this API, add this behavior to a GameObject in your scene, or use the
             GvrControllerMain prefab. There can only be one object with this behavior on your scene.
            
             This is a singleton object.
            
             To access the controller state, simply read the static properties of this class. For example,
             to know the controller's current orientation, use GvrController.Orientation.
        </member>
        <member name="T:GvrControllerVisual">
            Provides visual feedback for the daydream controller.
        </member>
        <member name="T:GvrControllerVisualManager">
            Manages when the visual elements of GvrControllerPointer should be active.
            When the controller is disconnected, the visual elements will be turned off.
        </member>
        <member name="T:IGvrPointerHoverHandler">
            Interface to implement if you wish to receive OnGvrPointerHover callbacks.
            Executed by GazeInputModule.cs.
        </member>
        <member name="M:IGvrPointerHoverHandler.OnGvrPointerHover(UnityEngine.EventSystems.PointerEventData)">
            Called when pointer is hovering over GameObject.
        </member>
        <member name="T:GvrExecuteEventsExtension">
            This script extends the standard Unity EventSystem events with Gvr specific events.
        </member>
        <member name="T:GvrEye">
             Controls one camera of a stereo pair.  Each frame, it mirrors the settings of
             the parent mono Camera, and then sets up side-by-side stereo with
             the view and projection matrices from the GvrViewer.EyeView and GvrViewer.Projection.
             The render output is directed to the GvrViewer.StereoScreen render texture, either
             to the left half or right half depending on the chosen eye.
            
             To enable a stereo camera pair, enable the parent mono camera and set
             GvrViewer.vrModeEnabled = true.
            
             @note If you programmatically change the set of GvrEyes belonging to a
             StereoController, be sure to call StereoController::InvalidateEyes on it
             in order to reset its cache.
        </member>
        <member name="F:GvrEye.eye">
            Whether this is the left eye or the right eye.
            Determines which stereo eye to render, that is, which `EyeOffset` and
            `Projection` matrix to use and which half of the screen to render to.
        </member>
        <member name="F:GvrEye.toggleCullingMask">
            Allows you to flip on or off specific culling mask layers for just this
            eye.  The mask is a toggle:  The eye's culling mask is first copied from
            the parent mono camera, and then the layers specified here are flipped.
            Each eye has its own toggle mask.
        </member>
        <member name="P:GvrEye.Controller">
            The StereoController in charge of this eye (and whose mono camera
            we will copy settings from).
        </member>
        <member name="P:GvrEye.Head">
            Returns the closest ancestor GvrHead.
            @note Uses GetComponentInParent(), so the result will be null if no active ancestor is found.
        </member>
        <member name="M:GvrEye.CopyCameraAndMakeSideBySide(StereoController,System.Single,System.Single)">
            Helper to copy camera settings from the controller's mono camera.  Used in SetupStereo() and
            in the custom editor for StereoController.  The parameters parx and pary, if not left at
            default, should come from a projection matrix returned by the SDK.  They affect the apparent
            depth of the camera's window.  See SetupStereo().
        </member>
        <member name="T:GvrGaze">
            Class that can perform gaze-based selection, as a simple alternative to the
            more complicated path of using _GazeInputModule_ and the rest of **uGUI**.
        </member>
        <member name="P:GvrGaze.PointerObject">
            The active Gaze Pointer for this camera. Must have IGvrPointer.
            The IGvrPointer responds to events from this class.
        </member>
        <member name="F:GvrGaze.mask">
            The layers to use for finding objects which intersect the user's gaze.
        </member>
        <member name="T:GvrHead">
             This script provides head tracking support for a camera.
            
             Attach this script to any game object that should match the user's head motion.
             By default, it continuously updates the local transform to GvrViewer.HeadView.
             A target object may be specified to provide an alternate reference frame for the motion.
            
             This script will typically be attached directly to a _Camera_ object, or to its
             parent if you need to offset the camera from the origin.
             Alternatively it can be inserted as a child of the _Camera_ but parent of the
             GvrEye camera.  Do this if you already have steering logic driving the
             mono Camera and wish to have the user's head motion be relative to that.  Note
             that in the latter setup, head tracking is visible only when VR Mode is enabled.
            
             In some cases you may need two instances of GvrHead, referring to two
             different targets (one of which may be the parent), in order to split where
             the rotation is applied from where the positional offset is applied.  Use the
             #trackRotation and #trackPosition properties in this case.
        </member>
        <member name="F:GvrHead.trackRotation">
            Determines whether to apply the user's head rotation to this gameobject's
            orientation.  True means to update the gameobject's orientation with the
            user's head rotation, and false means don't modify the gameobject's orientation.
        </member>
        <member name="F:GvrHead.trackPosition">
            Determines whether to apply ther user's head offset to this gameobject's
            position.  True means to update the gameobject's position with the user's head offset,
            and false means don't modify the gameobject's position.
        </member>
        <member name="F:GvrHead.target">
            The user's head motion will be applied in this object's reference frame
            instead of the head object's parent.  A good use case is for head-based
            steering.  Normally, turning the parent object (i.e. the body or vehicle)
            towards the direction the user is looking would carry the head along with it,
            thus creating a positive feedback loop.  Use an external target object as a
            fixed point of reference for the direction the user is looking.  Often, the
            grandparent or higher ancestor is a suitable target.
        </member>
        <member name="F:GvrHead.updateEarly">
             Determines whether the head tracking is applied during `LateUpdate()` or
             `Update()`.  The default is false, which means it is applied during `LateUpdate()`
             to reduce latency.
            
             However, some scripts may need to use the camera's direction to affect the gameplay,
             e.g by casting rays or steering a vehicle, during the `LateUpdate()` phase.
             This can cause an annoying jitter because Unity, during this `LateUpdate()`
             phase, will update the head object first on some frames but second on others.
             If this is the case for your game, try switching the head to apply head tracking
             during `Update()` by setting this to true.
        </member>
        <member name="P:GvrHead.Gaze">
            Returns a ray based on the heads position and forward direction, after making
            sure the transform is up to date.  Use to raycast into the scene to determine
            objects that the user is looking at.
        </member>
        <member name="E:GvrHead.OnHeadUpdated">
            Called after the head pose has been updated with the latest sensor data.
        </member>
        <member name="T:GvrIntent">
            <summary>
            Provides information about the Android Intent that started the current Activity.
            </summary>
        </member>
        <member name="T:GvrLaserPointer">
            Implementation of IGvrPointer for a laser pointer visual.
            This script should be attached to the controller object.
            The laser visual is important to help users locate their cursor
            when its not directly in their field of view.
        </member>
        <member name="M:GvrPermissionsRequester.GetActivity">
            <summary>
            Gets the Unity player activity.
            </summary>
            <returns>The activity.</returns>
        </member>
        <member name="P:GvrPermissionsRequester.Instance">
            The singleton instance of the PermissionsRequester class,
            lazily instanciated.
        </member>
        <member name="M:GvrPermissionsRequester.InitializeFragment">
            <summary>
            Initializes the fragment via JNI.
            </summary>
            <returns>True if fragment was initialized.</returns>
        </member>
        <member name="T:GvrPermissionsRequester.PermissionsCallback">
            <summary>
            Permissions callback implementation.
            </summary>
            <remarks>Instances of this class are passed to the java fragment and then
            invoked once the request process is completed by the user.
            </remarks>
        </member>
        <member name="M:GvrPermissionsRequester.PermissionsCallback.onRequestPermissionResult(System.Boolean)">
            <summary>
            Called when then permission request flow is completed.
            </summary>
            <param name="allPermissionsGranted">
                True if all permissions granted.</param>
        </member>
        <member name="T:GvrPointerGraphicRaycaster">
             This script provides a raycaster for use with the GvrPointerInputModule.
             It behaves similarly to the standards Graphic raycaster, except that it utilize raycast
             modes specifically for Gvr.
            
             View GvrBasePointerRaycaster.cs and GvrPointerInputModule.cs for more details.
        </member>
        <member name="M:GvrPointerGraphicRaycaster.Raycast(UnityEngine.Canvas,UnityEngine.Ray,UnityEngine.Camera,System.Single,System.Collections.Generic.List{UnityEngine.UI.Graphic},UnityEngine.Ray@)">
            Perform a raycast into the screen and collect all graphics underneath it.
        </member>
        <member name="T:GvrPointerInputModule">
             This script provides an implemention of Unity's `BaseInputModule` class, so
             that Canvas-based (_uGUI_) UI elements and 3D scene objects can be
             interacted with in a Gvr Application.
            
             This script is intended for use with either a
             3D pointer with the Daydream Controller (Recommended for Daydream),
             or a Gaze-based-pointer (Recommended for Cardboard).
            
             To use, attach to the scene's **EventSystem** object.  Be sure to move it above the
             other modules, such as _TouchInputModule_ and _StandaloneInputModule_, in order
             for the pointer to take priority in the event system.
            
             If you are using a **Canvas**, set the _Render Mode_ to **World Space**,
             and add the _GvrPointerGraphicRaycaster_ script to the object.
            
             If you'd like pointers to work with 3D scene objects, add a _GvrPointerPhysicsRaycaster_ to the main camera,
             and add a component that implements one of the _Event_ interfaces (_EventTrigger_ will work nicely) to
             an object with a collider.
            
             GvrPointerInputModule emits the following events: _Enter_, _Exit_, _Down_, _Up_, _Click_, _Select_,
             _Deselect_, _UpdateSelected_, and _GvrPointerHover_.  Scroll, move, and submit/cancel events are not emitted.
            
             To use a 3D Pointer with the Daydream Controller:
               - Add the prefab GoogleVR/Prefabs/UI/GvrControllerPointer to your scene.
               - Set the parent of GvrControllerPointer to the same parent as the main camera
                 (With a local position of 0,0,0).
            
             To use a Gaze-based-pointer:
               - Add the prefab GoogleVR/Prefabs/UI/GvrReticlePointer to your scene.
               - Set the parent of GvrReticlePointer to the main camera.
            
        </member>
        <member name="F:GvrPointerInputModule.vrModeOnly">
            Determines whether pointer input is active in VR Mode only (`true`), or all of the
            time (`false`).  Set to false if you plan to use direct screen taps or other
            input when not in VR Mode.
        </member>
        <member name="F:GvrPointerInputModule.CLICK_TIME">
            Time in seconds between the pointer down and up events sent by a trigger.
            Allows time for the UI elements to make their state transitions.
        </member>
        <member name="F:GvrPointerInputModule.SCROLL_DELTA_MULTIPLIER">
            Multiplier for calculating the scroll delta to that the scroll delta is
            within the order of magnitude that the UI system expects.
        </member>
        <member name="P:GvrPointerInputModule.pointer">
            The IGvrPointer which will be responding to pointer events.
        </member>
        <member name="M:GvrPointerInputModule.ShouldActivateModule">
            @cond
        </member>
        <member name="M:GvrPointerInputModule.DeactivateModule">
            @endcond
        </member>
        <member name="M:GvrPointerInputModule.CastRay">
            @endcond
        </member>
        <member name="T:GvrPointerManager">
             GvrPointerManager is a standard interface for
             controlling which IGvrPointer is being used
             for user input affordance.
            
        </member>
        <member name="P:GvrPointerManager.Pointer">
            Change the IGvrPointer that is currently being used.
        </member>
        <member name="M:GvrPointerManager.OnPointerCreated(IGvrPointer)">
             GvrBasePointer calls this when it is created.
             If a pointer hasn't already been assigned, it
             will assign the newly created one by default.
            
             This simplifies the common case of having only one
             IGvrPointer so is can be automatically hooked up
             to the manager.  If multiple GvrGazePointers are in
             the scene, the app has to take responsibility for
             setting which one is active.
        </member>
        <member name="T:GvrPointerPhysicsRaycaster">
             This script provides a raycaster for use with the GvrPointerInputModule.
             It behaves similarly to the standards Physics raycaster, except that it utilize raycast
             modes specifically for Gvr.
            
             View GvrBasePointerRaycaster.cs and GvrPointerInputModule.cs for more details.
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.NO_EVENT_MASK_SET">
            Const to use for clarity when no event mask is set
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.raycasterEventMask">
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
        </member>
        <member name="F:GvrPointerPhysicsRaycaster.cachedEventCamera">
            Stored reference to the event camera.
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.eventCamera">
            eventCamera is used for masking layers and determining the distance of the raycast.
            It will use the camera on the same object as this script.
            If there is none, it will use the main camera.
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.finalEventMask">
            Event mask used to determine which objects will receive events.
        </member>
        <member name="P:GvrPointerPhysicsRaycaster.eventMask">
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
        </member>
        <member name="T:GvrPostRender">
             Performs distortion correction on the rendered stereo screen.  This script
             and GvrPreRender work together to draw the whole screen in VR Mode.
             There should be exactly one of each component in any GVR-enabled scene. It
             is part of the _GvrCamera_ prefab, which is included in
             _GvrMain_. The GvrViewer script will create one at runtime if the
             scene doesn't already have it, so generally it is not necessary to manually
             add it unless you wish to edit the Camera component that it controls.
            
             In the Unity editor, this script also draws the analog of the UI layer on
             the phone (alignment marker, settings gear, etc).
        </member>
        <member name="T:GvrPreRender">
            Clears the entire screen.  This script and GvrPostRender work together
            to draw the whole screen in VR Mode.  There should be exactly one of each
            component in any GVR-enabled scene.  It is part of the _GvrCamera_
            prefab, which is included in _GvrMain_.  The GvrViewer script will
            create one at runtime if the scene doesn't already have it, so generally
            it is not necessary to manually add it unless you wish to edit the _Camera_
            component that it controls.
        </member>
        <member name="T:GvrProfile">
            @cond
            Measurements of a particular phone in a particular VR viewer.
        </member>
        <member name="T:GvrProfile.Screen">
            Information about the screen.  All distances are in meters, measured relative to how
            the phone is expected to be seated in the viewer, i.e. landscape orientation.
        </member>
        <member name="T:GvrProfile.Lenses">
            Information about the lens placement in the viewer.  All distances are in meters.
        </member>
        <member name="T:GvrProfile.MaxFOV">
            Information about the viewing angles through the lenses.  All angles in degrees, measured
            away from the optical axis, i.e. angles are all positive.  It is assumed that left and right
            eye FOVs are mirror images, so that both have the same inner and outer angles.  Angles do not
            need to account for the limits due to screen size.
        </member>
        <member name="T:GvrProfile.Distortion">
            Information on how the lens distorts light rays.  Also used for the (approximate) inverse
            distortion.  Assumes a radially symmetric pincushion/barrel distortion model.
        </member>
        <member name="T:GvrProfile.Viewer">
            Information about a particular device, including specfications on its lenses, FOV,
            and distortion and inverse distortion coefficients.
        </member>
        <member name="F:GvrProfile.screen">
            Screen parameters of a Cardboard device.
        </member>
        <member name="F:GvrProfile.viewer">
            Viewer parameters of a Cardboard device.
        </member>
        <member name="P:GvrProfile.VerticalLensOffset">
            The vertical offset of the lens centers from the screen center.
        </member>
        <member name="T:GvrProfile.ScreenSizes">
            Some known screen profiles.
        </member>
        <member name="F:GvrProfile.Nexus5">
            Parameters for a Nexus 5 device.
        </member>
        <member name="F:GvrProfile.Nexus6">
            Parameters for a Nexus 6 device.
        </member>
        <member name="F:GvrProfile.GalaxyS6">
            Parameters for a Galaxy S6 device.
        </member>
        <member name="F:GvrProfile.GalaxyNote4">
            Parameters for a Galaxy Note4 device.
        </member>
        <member name="F:GvrProfile.LGG3">
            Parameters for a LG G3 device.
        </member>
        <member name="F:GvrProfile.iPhone4">
            Parameters for an iPhone 4 device.
        </member>
        <member name="F:GvrProfile.iPhone5">
            Parameters for an iPhone 5 device.
        </member>
        <member name="F:GvrProfile.iPhone6">
            Parameters for an iPhone 6 device.
        </member>
        <member name="F:GvrProfile.iPhone6p">
            Parameters for an iPhone 6p device.
        </member>
        <member name="T:GvrProfile.ViewerTypes">
            Some known Cardboard device profiles.
        </member>
        <member name="F:GvrProfile.CardboardJun2014">
            Parameters for a Cardboard v1.
        </member>
        <member name="F:GvrProfile.CardboardMay2015">
            Parameters for a Cardboard v2.
        </member>
        <member name="F:GvrProfile.GoggleTechC1Glass">
            Parameters for a Go4D C1-Glass.
        </member>
        <member name="F:GvrProfile.Default">
            Nexus 5 in a Cardboard v1.
        </member>
        <member name="M:GvrProfile.GetKnownProfile(GvrProfile.ScreenSizes,GvrProfile.ViewerTypes)">
            Returns a profile with the given parameters.
        </member>
        <member name="M:GvrProfile.GetLeftEyeVisibleTanAngles(System.Single[])">
            Calculates the tan-angles from the maximum FOV for the left eye for the
            current device and screen parameters.
        </member>
        <member name="M:GvrProfile.GetLeftEyeNoLensTanAngles(System.Single[])">
            Calculates the tan-angles from the maximum FOV for the left eye for the
            current device and screen parameters, assuming no lenses.
        </member>
        <member name="M:GvrProfile.GetLeftEyeVisibleScreenRect(System.Single[])">
            Calculates the screen rectangle visible from the left eye for the
            current device and screen parameters.
        </member>
        <member name="M:GvrProfile.ApproximateInverse(System.Single[],System.Single,System.Int32)">
            Calculates an approximate inverse to the given radial distortion parameters.
        </member>
        <member name="M:GvrProfile.ApproximateInverse(GvrProfile.Distortion,System.Single,System.Int32)">
            Calculates an approximate inverse to the given radial distortion parameters.
        </member>
        <member name="T:GvrReticlePointer">
            Draws a circular reticle in front of any object that the user points at.
            The circle dilates if the object is clickable.
        </member>
        <member name="F:GvrReticlePointer.reticleSegments">
            Number of segments making the reticle circle.
        </member>
        <member name="F:GvrReticlePointer.reticleGrowthSpeed">
            Growth speed multiplier for the reticle/
        </member>
        <member name="M:GvrReticlePointer.OnInputModuleEnabled">
            This is called when the 'BaseInputModule' system should be enabled.
        </member>
        <member name="M:GvrReticlePointer.OnInputModuleDisabled">
            This is called when the 'BaseInputModule' system should be disabled.
        </member>
        <member name="M:GvrReticlePointer.OnPointerEnter(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Ray,System.Boolean)">
             Called when the user is pointing at valid GameObject. This can be a 3D
             or UI element.
            
             The targetObject is the object the user is pointing at.
             The intersectionPosition is where the ray intersected with the targetObject.
             The intersectionRay is the ray that was cast to determine the intersection.
        </member>
        <member name="M:GvrReticlePointer.OnPointerHover(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Ray,System.Boolean)">
             Called every frame the user is still pointing at a valid GameObject. This
             can be a 3D or UI element.
            
             The targetObject is the object the user is pointing at.
             The intersectionPosition is where the ray intersected with the targetObject.
             The intersectionRay is the ray that was cast to determine the intersection.
        </member>
        <member name="M:GvrReticlePointer.OnPointerExit(UnityEngine.GameObject)">
            Called when the user's look no longer intersects an object previously
            intersected with a ray projected from the camera.
            This is also called just before **OnInputModuleDisabled** and may have have any of
            the values set as **null**.
        </member>
        <member name="M:GvrReticlePointer.OnPointerClickDown">
            Called when a trigger event is initiated. This is practically when
            the user begins pressing the trigger.
        </member>
        <member name="M:GvrReticlePointer.OnPointerClickUp">
            Called when a trigger event is finished. This is practically when
            the user releases the trigger.
        </member>
        <member name="T:GvrTooltip">
            A tooltip for displaying control schemes overlaying the controller visual using a Unity Canvas.
            Automatically changes what side of the controller the tooltip is shown on depending
            on the handedness setting for the player.
            Automatically fades out when the controller visual is too close or too far
            away from the player's head.
            Look at the prefab GvrControllerPointer to see an example of how to use this script.
        </member>
        <member name="T:GvrUnitySdkVersion">
            <summary>
            Provides and logs versioning information for the GVR Unity SDK.
            </summary>
        </member>
        <member name="T:GvrVideoPlayerTexture">
            <summary>
            Plays video using Exoplayer rendering it on the main texture.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoTextures">
            <summary>
            The video texture array used as a circular buffer to get the video image.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoPlayerPtr">
            <summary>
            The video player pointer used to uniquely identify the player instance.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoPlayerEventBase">
            <summary>
            The video player event base.
            </summary>
            <remarks>This is added to the event id when issues events to
                the plugin.
            </remarks>
        </member>
        <member name="F:GvrVideoPlayerTexture.renderEventFunction">
            <summary>
            The render event function.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.onEventCallbacks">
            <summary>List of callbacks to invoke when the video is ready.</summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.onExceptionCallbacks">
            <summary>List of callbacks to invoke on exception.</summary>
            <remarks>The first parameter is the type of exception,
                the second is the message.
            </remarks>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoType">
            <summary>
            Video type.
            </summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.VideoPlayerState">
            <summary>
            Video player state.
            </summary>
        </member>
        <member name="T:GvrVideoPlayerTexture.RenderCommand">
            <summary>
            Plugin render commands.
            </summary>
            <remarks>
            These are added to the eventbase for the specific player object and
              issued to the plugin.
            </remarks>
        </member>
        <member name="F:GvrVideoPlayerTexture.videoType">
            <summary>
            The type of the video.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.adjustAspectRatio">
            <summary>
            True for adjusting the aspect ratio of the renderer.
            </summary>
        </member>
        <member name="F:GvrVideoPlayerTexture.useSecurePath">
            <summary>
            The use secure path for DRM protected video.
            </summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.Awake">
            Create the video player instance and the event base id.
        </member>
        <!-- Badly formed XML comment ignored for member "M:GvrVideoPlayerTexture.SetDisplayTexture(UnityEngine.Texture)" -->
        <member name="M:GvrVideoPlayerTexture.RestartVideo">
            <summary>
            Resets the video player.
            </summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.Init">
            <summary>
            Initialize the video player.
            </summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:GvrVideoPlayerTexture.AdjustAspectRatio">
            <summary>
            Adjusts the aspect ratio.
            </summary>
            <remarks>
            This adjusts the transform scale to match the aspect
                ratio of the texture.
            </remarks>
        </member>
        <member name="M:GvrVideoPlayerTexture.CreateTextureForVideoMaybe">
            <summary>
            Creates the texture for video if needed.
            </summary>
        </member>
        <member name="M:GvrVideoPlayerTexture.IssuePlayerEvent(GvrVideoPlayerTexture.RenderCommand)">
            <summary>
            Issues the player event.
            </summary>
            <param name="evt">The event to send to the video player
                instance.
            </param>
        </member>
        <member name="T:GvrViewer">
             The GvrViewer object communicates with the head-mounted display.
             Is is repsonsible for:
             -  Querying the device for viewing parameters
             -  Retrieving the latest head tracking data
             -  Providing the rendered scene to the device for distortion correction (optional)
            
             There should only be one of these in a scene.  An instance will be generated automatically
             by this script at runtime, or you can add one via the Editor if you wish to customize
             its starting properties.
        </member>
        <member name="P:GvrViewer.Instance">
            The singleton instance of the GvrViewer class.
        </member>
        <member name="M:GvrViewer.Create">
            Generate a GvrViewer instance.  Takes no action if one already exists.
        </member>
        <member name="P:GvrViewer.Controller">
            The StereoController instance attached to the main camera, or null if there is none.
            @note Cached for performance.
        </member>
        <member name="P:GvrViewer.VRModeEnabled">
            Determine whether the scene renders in stereo or mono.
            Supported only for versions of Unity *without* the GVR integration.
            VRModeEnabled will be a no-op for versions of Unity with the GVR integration.
            _True_ means to render in stereo, and _false_ means to render in mono.
        </member>
        <member name="T:GvrViewer.DistortionCorrectionMethod">
            Methods for performing lens distortion correction.
        </member>
        <!-- Badly formed XML comment ignored for member "F:GvrViewer.DistortionCorrectionMethod.Native" -->
        <!-- Badly formed XML comment ignored for member "F:GvrViewer.DistortionCorrectionMethod.Unity" -->
        <member name="P:GvrViewer.DistortionCorrection">
            Determines the distortion correction method used by the SDK to render the
            #StereoScreen texture on the phone.  If _Native_ is selected but not supported
            by the device, the _Unity_ method will be used instead.
        </member>
        <member name="P:GvrViewer.NeckModelScale">
            The native SDK will apply a neck offset to the head tracking, resulting in
            a more realistic model of a person's head position.  This control determines
            the scale factor of the offset.  To turn off the neck model, set it to 0, and
            to turn it all on, set to 1.  Intermediate values can be used to animate from
            on to off or vice versa.
        </member>
        <member name="P:GvrViewer.NativeDistortionCorrectionSupported">
            Whether native distortion correction functionality is supported by the VR device.
        </member>
        <member name="P:GvrViewer.NativeUILayerSupported">
            Whether the VR device supports showing a native UI layer, for example for settings.
        </member>
        <member name="P:GvrViewer.StereoScreenScale">
            Scales the resolution of the #StereoScreen.  Set to less than 1.0 to increase
            rendering speed while decreasing sharpness, or greater than 1.0 to do the
            opposite.
        </member>
        <member name="P:GvrViewer.StereoScreen">
            The texture that Unity renders the scene to.  After the frame has been rendered,
            this texture is drawn to the screen with a lens distortion correction effect.
            The texture size is based on the size of the screen, the lens distortion
            parameters, and the #StereoScreenScale factor.
        </member>
        <member name="T:GvrViewer.StereoScreenChangeDelegate">
            A callback for notifications that the StereoScreen property has changed.
        </member>
        <member name="E:GvrViewer.OnStereoScreenChanged">
            Emitted when the StereoScreen property has changed.
        </member>
        <member name="P:GvrViewer.Profile">
            Describes the current device, including phone screen.
        </member>
        <member name="P:GvrViewer.NoNativeGVRSupport">
            Returns true if GoogleVR is NOT supported natively.
            That is, this version of Unity does not have native integration but supports
            the GVR SDK (5.2, 5.3), or the current VR player is the in-editor emulator.
        </member>
        <member name="T:GvrViewer.Eye">
            Distinguish the stereo eyes.
        </member>
        <!-- Badly formed XML comment ignored for member "F:GvrViewer.Eye.Right" -->
        <!-- Badly formed XML comment ignored for member "F:GvrViewer.Eye.Center" -->
        <member name="T:GvrViewer.Distortion">
            When retrieving the #Projection and #Viewport properties, specifies
            whether you want the values as seen through the viewer's lenses (`Distorted`) or
            as if no lenses were present (`Undistorted`).
        </member>
        <!-- Badly formed XML comment ignored for member "F:GvrViewer.Distortion.Undistorted" -->
        <member name="P:GvrViewer.HeadPose">
            The transformation of head from origin in the tracking system.
        </member>
        <member name="M:GvrViewer.EyePose(GvrViewer.Eye)">
            The transformation from head to eye.
        </member>
        <member name="M:GvrViewer.Projection(GvrViewer.Eye,GvrViewer.Distortion)">
            The projection matrix for a given eye.
            This matrix is an off-axis perspective projection with near and far
            clipping planes of 1m and 1000m, respectively.  The GvrEye script
            takes care of adjusting the matrix for its particular camera.
        </member>
        <member name="M:GvrViewer.Viewport(GvrViewer.Eye,GvrViewer.Distortion)">
            The screen space viewport that the camera for the specified eye should render into.
            In the _Distorted_ case, this will be either the left or right half of the `StereoScreen`
            render texture.  In the _Undistorted_ case, it refers to the actual rectangle on the
            screen that the eye can see.
        </member>
        <member name="P:GvrViewer.ComfortableViewingRange">
            The distance range from the viewer in user-space meters where objects may be viewed
            comfortably in stereo.  If the center of interest falls outside this range, the stereo
            eye separation should be adjusted to keep the onscreen disparity within the limits set
            by this range.  If native integration is not supported, or the current VR player is the
            in-editor emulator, StereoController will handle this if the _checkStereoComfort_ is
            enabled.
        </member>
        <member name="F:GvrViewer.DefaultDeviceProfile">
            @cond
        </member>
        <member name="M:GvrViewer.InitDevice">
            @endcond
        </member>
        <member name="M:GvrViewer.Awake">
            @note Each scene load causes an OnDestroy of the current SDK, followed
            by and Awake of a new one.  That should not cause the underlying native
            code to hiccup.  Exception: developer may call Application.DontDestroyOnLoad
            on the SDK if they want it to survive across scene loads.
        </member>
        <member name="P:GvrViewer.Triggered">
            Whether the viewer's trigger was pulled. True for exactly one complete frame
            after each pull.
        </member>
        <member name="P:GvrViewer.Tilted">
            Whether the viewer was tilted on its side. True for exactly one complete frame
            after each tilt.  Whether and how to respond to this event is up to the app.
        </member>
        <member name="P:GvrViewer.ProfileChanged">
            Whether the viewer profile has possibly changed.  This is meant to indicate
            that a new QR code has been scanned, although currently it is actually set any time the
            application is unpaused, whether it was due to a profile change or not.  True for one
            frame.
        </member>
        <member name="P:GvrViewer.BackButtonPressed">
            Whether the user has pressed the "VR Back Button", which on Android should be treated the
            same as the normal system Back Button, although you can respond to either however you want
            in your app.
        </member>
        <member name="M:GvrViewer.UpdateState">
             Reads the latest tracking data from the phone.  This must be
             called before accessing any of the poses and matrices above.
            
             Multiple invocations per frame are OK:  Subsequent calls merely yield the
             cached results of the first call.  To minimize latency, it should be first
             called later in the frame (for example, in `LateUpdate`) if possible.
        </member>
        <member name="M:GvrViewer.PostRender(UnityEngine.RenderTexture)">
            Presents the #StereoScreen to the device for distortion correction and display.
            @note This function is only used if #DistortionCorrection is set to _Native_,
            and it only has an effect if the device supports it.
        </member>
        <member name="M:GvrViewer.Recenter">
            Resets the tracker so that the user's current direction becomes forward.
        </member>
        <member name="M:GvrViewer.ShowSettingsDialog">
            Launch the device pairing and setup dialog.
        </member>
        <member name="M:GvrViewer.AddStereoControllerToCameras">
            Add a StereoController to any camera that does not have a Render Texture (meaning it is
            rendering to the screen).
        </member>
        <member name="T:IGvrGazePointer">
             This script provides an interface for gaze based input pointers used with
             the GazeInputModule script.
            
             It provides methods called on gaze interaction with in-game objects and UI,
             trigger events, and 'BaseInputModule' class state changes.
            
             To have the methods called, an instance of this (implemented) class must be
             registered with the **GazeInputModule** script on 'OnEnable' by assigning
             itself to the **GazeInputModule.gazePointer** static member variable.
             A registered instance should also un-register itself at 'OnDisable' calls
             by setting the **GazeInputModule.gazePointer** static member variable
             to null.
            
             This class is expected to be inherited by pointers responding to the user's
             looking at objects in the scene by the movement of their head. For example,
             see the GvrReticle class.
        </member>
        <member name="M:IGvrGazePointer.OnGazeEnabled">
            This is called when the 'BaseInputModule' system should be enabled.
        </member>
        <member name="M:IGvrGazePointer.OnGazeDisabled">
            This is called when the 'BaseInputModule' system should be disabled.
        </member>
        <member name="M:IGvrGazePointer.OnGazeStart(UnityEngine.Camera,UnityEngine.GameObject,UnityEngine.Vector3,System.Boolean)">
             Called when the user is looking on a valid GameObject. This can be a 3D
             or UI element.
            
             The camera is the event camera, the target is the object
             the user is looking at, and the intersectionPosition is the intersection
             point of the ray sent from the camera on the object.
        </member>
        <member name="M:IGvrGazePointer.OnGazeStay(UnityEngine.Camera,UnityEngine.GameObject,UnityEngine.Vector3,System.Boolean)">
             Called every frame the user is still looking at a valid GameObject. This
             can be a 3D or UI element.
            
             The camera is the event camera, the target is the object the user is
             looking at, and the intersectionPosition is the intersection point of the
             ray sent from the camera on the object.
        </member>
        <member name="M:IGvrGazePointer.OnGazeExit(UnityEngine.Camera,UnityEngine.GameObject)">
             Called when the user's look no longer intersects an object previously
             intersected with a ray projected from the camera.
             This is also called just before **OnGazeDisabled** and may have have any of
             the values set as **null**.
            
             The camera is the event camera and the target is the object the user
             previously looked at.
        </member>
        <member name="M:IGvrGazePointer.OnGazeTriggerStart(UnityEngine.Camera)">
            Called when a trigger event is initiated. This is practically when
            the user begins pressing the trigger.
        </member>
        <member name="M:IGvrGazePointer.OnGazeTriggerEnd(UnityEngine.Camera)">
            Called when trigger event is finished. This is practically when
            the user releases the trigger.
        </member>
        <member name="M:IGvrGazePointer.GetPointerRadius(System.Single@,System.Single@)">
            Return the radius of the gaze pointer. This is used when searching for
            valid gaze targets. If a radius is 0, the GvrGaze will use a ray
            to find a valid gaze target. Otherwise it will use a SphereCast.
            The *innerRadius* is used for finding new targets while the *outerRadius*
            is used to see if you are still nearby the object currently looked at
            to avoid a flickering effect when just at the border of the intersection.
        </member>
        <member name="T:IGvrGazeResponder">
            This script provides an interface for gaze based responders used with
            the GvrGaze script.
        </member>
        <member name="M:IGvrGazeResponder.OnGazeEnter">
            Called when the user is looking on a GameObject with this script,
            as long as it is set to an appropriate layer (see GvrGaze).
        </member>
        <member name="M:IGvrGazeResponder.OnGazeExit">
            Called when the user stops looking on the GameObject, after OnGazeEnter
            was already called.
        </member>
        <member name="M:IGvrGazeResponder.OnGazeTrigger">
            Called when the trigger is used, between OnGazeEnter and OnGazeExit.
        </member>
        <member name="T:IGvrPointer">
             This script provides an interface for pointer based input used with
             the GvrPointerInputModule script.
            
             It provides methods called on pointer interaction with in-game objects and UI,
             trigger events, and 'BaseInputModule' class state changes.
            
             To have the methods called, an instance of this (implemented) class must be
             registered with the **GvrPointerManager** script on 'OnEnable' by calling
             GvrPointerManager.OnPointerCreated.
             A registered instance should also un-register itself at 'OnDisable' calls
             by setting the **GvrPointerManager.Pointer** static property
             to null.
            
             This class is expected to be inherited by pointers doing 1 of 2 things:
             1. Responding to movement of the users head (Cardboard gaze-based-pointer).
             2. Responding to the movement of the daydream controller (Daydream 3D pointer).
        </member>
        <member name="P:IGvrPointer.ShouldUseExitRadiusForRaycast">
            This is used by GvrBasePointerRaycaster to determine if the
            enterRadius or the exitRadius should be used for the raycast.
            It is set by GvrPointerInputModule and doesn't need to be controlled manually.
        </member>
        <member name="M:IGvrPointer.OnInputModuleEnabled">
            This is called when the 'BaseInputModule' system should be enabled.
        </member>
        <member name="M:IGvrPointer.OnInputModuleDisabled">
            This is called when the 'BaseInputModule' system should be disabled.
        </member>
        <member name="M:IGvrPointer.OnPointerEnter(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Ray,System.Boolean)">
             Called when the pointer is facing a valid GameObject. This can be a 3D
             or UI element.
            
             The targetObject is the object the user is pointing at.
             The intersectionPosition is where the ray intersected with the targetObject.
             The intersectionRay is the ray that was cast to determine the intersection.
        </member>
        <member name="M:IGvrPointer.OnPointerHover(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Ray,System.Boolean)">
             Called every frame the user is still pointing at a valid GameObject. This
             can be a 3D or UI element.
            
             The targetObject is the object the user is pointing at.
             The intersectionPosition is where the ray intersected with the targetObject.
             The intersectionRay is the ray that was cast to determine the intersection.
        </member>
        <member name="M:IGvrPointer.OnPointerExit(UnityEngine.GameObject)">
            Called when the pointer no longer faces an object previously
            intersected with a ray projected from the camera.
            This is also called just before **OnInputModuleDisabled** and may have have any of
            the values set as **null**.
        </member>
        <member name="M:IGvrPointer.OnPointerClickDown">
            Called when a click is initiated.
        </member>
        <member name="M:IGvrPointer.OnPointerClickUp">
            Called when click is finished.
        </member>
        <member name="M:IGvrPointer.GetMaxPointerDistance">
            Returns the max distance this pointer will be rendered at from the camera.
            This is used by GvrBasePointerRaycaster to calculate the ray when using
            the default "Camera" RaycastMode. See GvrBasePointerRaycaster.cs for details.
        </member>
        <member name="M:IGvrPointer.GetPointerTransform">
            Returns the transform that represents this pointer.
            It is used by GvrBasePointerRaycaster as the origin of the ray.
        </member>
        <member name="M:IGvrPointer.GetPointerRadius(System.Single@,System.Single@)">
             Return the radius of the pointer. It is used by GvrPointerPhysicsRaycaster
             and GvrGaze when searching for valid pointer targets. If a radius is 0, then
             a ray is used to find a valid pointer target. Otherwise it will use a SphereCast.
             The *enterRadius* is used for finding new targets while the *exitRadius*
             is used to see if you are still nearby the object currently pointed at
             to avoid a flickering effect when just at the border of the intersection.
            
             NOTE: This is only works with GvrPointerPhysicsRaycaster. To use it with uGUI,
             add 3D colliders to your canvas elements.
        </member>
        <member name="T:OVRBoundary">
            <summary>
            Provides access to the Oculus boundary system.
            </summary>
        </member>
        <member name="T:OVRBoundary.Node">
            <summary>
            Specifies a tracked node that can be queried through the boundary system.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.HandRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.Head" -->
        <member name="T:OVRBoundary.BoundaryType">
            <summary>
            Specifies a boundary type surface.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryType.PlayArea" -->
        <member name="T:OVRBoundary.BoundaryTestResult">
            <summary>
            Provides test results of boundary system queries.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestDistance" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPoint" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPointNormal" -->
        <member name="T:OVRBoundary.BoundaryLookAndFeel">
            <summary>
            Specifies the boundary system parameters that can be configured. Can be overridden by the system or user.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetConfigured">
            <summary>
            Returns true if the boundary system is currently configured with valid boundary data.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestNode(OVRBoundary.Node,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a tracked node against the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestPoint(UnityEngine.Vector3,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a 3d point against the specified boundary type.
            The test point is expected in local tracking space.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.SetLookAndFeel(OVRBoundary.BoundaryLookAndFeel)">
            <summary>
            Requests that the visual look and feel of the boundary system be changed as specified. Can be overridden by the system or user.
            </summary>
        </member>
        <member name="M:OVRBoundary.ResetLookAndFeel">
            <summary>
            Resets the visual look and feel of the boundary system to the initial system settings.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetGeometry(OVRBoundary.BoundaryType)">
            <summary>
            Returns an array of 3d points (in clockwise order) that define the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetDimensions(OVRBoundary.BoundaryType)">
            <summary>
            Returns a vector that indicates the spatial dimensions of the specified boundary type. (x = width, y = height, z = depth)
            </summary>
        </member>
        <member name="M:OVRBoundary.GetVisible">
            <summary>
            Returns true if the boundary system is currently visible.
            </summary>
        </member>
        <member name="M:OVRBoundary.SetVisible(System.Boolean)">
            <summary>
            Requests that the boundary system visibility be set to the specified value.
            The actual visibility can be overridden by the system (i.e., proximity trigger) or by the user (boundary system disabled)
            </summary>
        </member>
        <member name="T:OVRCameraRig">
            <summary>
            A head-tracked stereoscopic virtual reality camera rig.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeCamera">
            <summary>
            The left eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeCamera">
            <summary>
            The right eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackingSpace">
            <summary>
            Provides a root transform for all anchors in tracking space.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeAnchor">
            <summary>
            Always coincides with the pose of the left eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.centerEyeAnchor">
            <summary>
            Always coincides with average of the left and right eye poses.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeAnchor">
            <summary>
            Always coincides with the pose of the right eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftHandAnchor">
            <summary>
            Always coincides with the pose of the left hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightHandAnchor">
            <summary>
            Always coincides with the pose of the right hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackerAnchor">
            <summary>
            Always coincides with the pose of the sensor.
            </summary>
        </member>
        <member name="E:OVRCameraRig.UpdatedAnchors">
            <summary>
            Occurs when the eye pose anchors have been set.
            </summary>
        </member>
        <member name="F:OVRCameraRig.usePerEyeCameras">
            <summary>
            If true, separate cameras will be used for the left and right eyes.
            </summary>
        </member>
        <member name="T:OVRChromaticAberration">
            <summary>
            Allows you to toggle chromatic aberration correction with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRChromaticAberration.toggleButton">
            <summary>
            The button that will toggle chromatic aberration correction.
            </summary>
        </member>
        <member name="T:OVRExtensions">
            <summary>
            Miscellaneous extension methods that any script can use.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToTrackingSpacePose(UnityEngine.Transform)">
            <summary>
            Converts the given world-space transform to an OVRPose in tracking space.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToHeadSpacePose(UnityEngine.Transform)">
            <summary>
            Converts the given world-space transform to an OVRPose in head space.
            </summary>
        </member>
        <member name="T:OVRPose">
            <summary>
            An affine transformation built from a Unity position and orientation.
            </summary>
        </member>
        <member name="P:OVRPose.identity">
            <summary>
            A pose with no translation or rotation.
            </summary>
        </member>
        <member name="F:OVRPose.position">
            <summary>
            The position.
            </summary>
        </member>
        <member name="F:OVRPose.orientation">
            <summary>
            The orientation.
            </summary>
        </member>
        <member name="M:OVRPose.op_Multiply(OVRPose,OVRPose)">
            <summary>
            Multiplies two poses.
            </summary>
        </member>
        <member name="M:OVRPose.Inverse">
            <summary>
            Computes the inverse of the given pose.
            </summary>
        </member>
        <member name="M:OVRPose.flipZ">
            <summary>
            Converts the pose from left- to right-handed or vice-versa.
            </summary>
        </member>
        <member name="T:OVRCubemapCapture">
            <summary>
            Helper script for capture cubemap and save it into PNG or JPG file
            </summary>
            <description>
            How it works:
            1) This script can be attached to a existing game object, you can also use prefab Assets\OVR\Prefabs\OVRCubemapCaptureProbe
            There are 2 ways to trigger a capture if you attached this script to a game object.  
            	* Automatic capturing: if [autoTriggerAfterLaunch] is true, a automatic capturing will be triggered after [autoTriggerDelay] seconds.
            	* Keyboard trigger: press key [triggeredByKey], a capturing will be triggered.
            2) If you like to trigger the screen capture in your code logic, just call static function [OVRCubemapCapture.TriggerCubemapCapture] with proper input arguments. 
            </description>
        </member>
        <member name="F:OVRCubemapCapture.autoTriggerAfterLaunch">
            <summary>
            Enable the automatic screenshot trigger, which will capture a cubemap after autoTriggerDelay (seconds)
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.triggeredByKey">
            <summary>
            Trigger cubemap screenshot if user pressed key triggeredByKey
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.pathName">
            <summary>
            The complete file path for saving the cubemap screenshot, including the filename and extension
            if pathName is blank, screenshots will be saved into %USERPROFILE%\Documents\OVR_ScreenShot360
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.cubemapSize">
            <summary>
            The cube face resolution
            </summary>
        </member>
        <member name="M:OVRCubemapCapture.TriggerCubemapCapture(UnityEngine.Vector3,System.Int32,System.String)">
            <summary>
            Generate unity cubemap at specific location and save into JPG/PNG
            </summary>
            <description>
            Default save folder: your app's persistentDataPath 
            Default file name: using current time OVR_hh_mm_ss.png 
            Note1: this will take a few seconds to finish
            Note2: if you only want to specify path not filename, please end [pathName] with "/" 
            </description>
        </member>
        <member name="M:OVRCubemapCapture.SaveCubemapCapture(UnityEngine.Cubemap,System.String)">
            <summary>
            Save unity cubemap into NPOT 6x1 cubemap/texture atlas in the following format PX NX PY NY PZ NZ
            </summary>
            <description>
            Supported format: PNG/JPG
            Default file name: using current time OVR_hh_mm_ss.png 
            </description>
        </member>
        <member name="T:OVRDebugHeadController">
            <summary>
            This is a simple behavior that can be attached to a parent of the CameraRig in order
            to provide movement via the gamepad. This is useful when testing an application in
            the Unity editor without the HMD.
            To use it, create a game object in your scene and drag your CameraRig to be a child
            of the game object. Then, add the OVRDebugHeadController behavior to the game object.
            Alternatively, this behavior can be placed directly on the OVRCameraRig object, but
            that is not guaranteed to work if OVRCameraRig functionality changes in the future.
            In the parent case, the object with OVRDebugHeadController can be thougt of as a 
            platform that your camera is attached to. When the platform moves or rotates, the 
            camera moves or rotates, but the camera can still move independently while "on" the
            platform.
            In general, this behavior should be disabled when not debugging.
            </summary>
        </member>
        <member name="T:OVRDebugInfo">
            <summary>
            Shows debug information on a heads-up display.
            </summary>
        </member>
        <member name="F:OVRDebugInfo.updateInterval">
            <summary>
            Variables for FPS
            </summary>
        </member>
        <member name="F:OVRDebugInfo.initUIComponent">
            <summary>
            Managing for UI initialization
            </summary>
        </member>
        <member name="F:OVRDebugInfo.offsetY">
            <summary>
            UIs Y offset
            </summary>
        </member>
        <member name="F:OVRDebugInfo.riftPresentTimeout">
            <summary>
            Managing for rift detection UI
            </summary>
        </member>
        <member name="F:OVRDebugInfo.showVRVars">
            <summary>
            Turn on / off VR variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Awake">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Update">
            <summary>
            Updating VR variables and managing UI present
            </summary>
        </member>
        <member name="M:OVRDebugInfo.OnDestroy">
            <summary>
            Initialize isInited value on OnDestroy
            </summary>
        </member>
        <member name="M:OVRDebugInfo.InitUIComponents">
            <summary>
            Initialize UI GameObjects
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateVariable">
            <summary>
            Update VR Variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateStrings">
            <summary>
            Update Strings
            </summary>
        </member>
        <member name="M:OVRDebugInfo.RiftPresentGUI(UnityEngine.GameObject)">
            <summary>
            It's for rift present GUI
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateDeviceDetection">
            <summary>
            Updates the device detection.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.VariableObjectManager(UnityEngine.GameObject,System.String,System.Single,System.String,System.Int32)">
            <summary>
            Object Manager for Variables
            </summary>
            <returns> gameobject for each Variable </returns>
        </member>
        <member name="M:OVRDebugInfo.ComponentComposition(UnityEngine.GameObject)">
            <summary>
            Component composition
            </summary>
            <returns> Composed gameobject. </returns>
        </member>
        <member name="M:OVRDebugInfo.UpdateIPD">
            <summary>
            Updates the IPD.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeHeightOffset">
            <summary>
            Updates the eye height offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeDepthOffset">
            <summary>
            Updates the eye depth offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFOV">
            <summary>
            Updates the FOV.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateResolutionEyeTexture">
            <summary>
            Updates resolution of eye texture
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateLatencyValues">
            <summary>
            Updates latency values
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFPS">
            <summary>
            Updates the FPS.
            </summary>
        </member>
        <member name="T:OVRDisplay">
            <summary>
            Manages an Oculus Rift head-mounted display (HMD).
            </summary>
        </member>
        <member name="T:OVRDisplay.EyeRenderDesc">
            <summary>
            Specifies the size and field-of-view for one eye texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.resolution">
            <summary>
            The horizontal and vertical size of the texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.fov">
            <summary>
            The angle of the horizontal and vertical field of view in degrees.
            </summary>
        </member>
        <member name="T:OVRDisplay.LatencyData">
            <summary>
            Contains latency measurements for a single frame of rendering.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.render">
            <summary>
            The time it took to render both eyes in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.timeWarp">
            <summary>
            The time it took to perform TimeWarp in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.postPresent">
            <summary>
            The time between the end of TimeWarp and scan-out in seconds.
            </summary>
        </member>
        <member name="M:OVRDisplay.#ctor">
            <summary>
            Creates an instance of OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="M:OVRDisplay.Update">
            <summary>
            Updates the internal state of the OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="E:OVRDisplay.RecenteredPose">
            <summary>
            Occurs when the head pose is reset.
            </summary>
        </member>
        <member name="M:OVRDisplay.RecenterPose">
            <summary>
            Recenters the head pose.
            </summary>
        </member>
        <member name="P:OVRDisplay.acceleration">
            <summary>
            Gets the current linear acceleration of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularAcceleration">
            <summary>
            Gets the current angular acceleration of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.velocity">
            <summary>
            Gets the current linear velocity of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularVelocity">
            <summary>
            Gets the current angular velocity of the head.
            </summary>
        </member>
        <member name="M:OVRDisplay.GetEyeRenderDesc(UnityEngine.VR.VRNode)">
            <summary>
            Gets the resolution and field of view for the given eye.
            </summary>
        </member>
        <member name="P:OVRDisplay.latency">
            <summary>
            Gets the current measured latency values.
            </summary>
        </member>
        <member name="P:OVRDisplay.recommendedMSAALevel">
            <summary>
            Gets the recommended MSAA level for optimal quality/performance the current device.
            </summary>
        </member>
        <member name="T:OVRGridCube">
            <summary>
            Diagnostic display with a regular grid of cubes for visual testing of
            tracking and distortion.
            </summary>
        </member>
        <member name="F:OVRGridCube.GridKey">
            <summary>
            The key that toggles the grid of cubes.
            </summary>
        </member>
        <member name="M:OVRGridCube.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRGridCube.SetOVRCameraController(OVRCameraRig@)">
            <summary>
            Sets the OVR camera controller.
            </summary>
            <param name="cameraController">Camera controller.</param>
        </member>
        <member name="M:OVRGridCube.CubeGridSwitchColor(System.Boolean)">
            <summary>
            Switch the Cube grid color.
            </summary>
            <param name="CubeSwitchColor">If set to <c>true</c> cube switch color.</param>
        </member>
        <member name="T:OVRHaptics">
            <summary>
            Plays tactile effects on a tracked VR controller.
            </summary>
        </member>
        <member name="T:OVRHaptics.Config">
            <summary>
            Determines the target format for haptics data on a specific device.
            </summary>
        </member>
        <member name="T:OVRHaptics.OVRHapticsChannel">
            <summary>
            A track of haptics data that can be mixed or sequenced with another track.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.#ctor(System.UInt32)">
            <summary>
            Constructs a channel targeting the specified output.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Preempt(OVRHapticsClip)">
            <summary>
            Cancels any currently-playing clips and immediatly plays the specified clip instead.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clips finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Mix(OVRHapticsClip)">
            <summary>
            Adds the specified clip to play simultaneously to the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Clear">
            <summary>
            Cancels any currently-playing clips.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Preempt(OVRHapticsClip)">
            <summary>
            Immediately plays the specified clip without waiting for any currently-playing clip to finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clip finishes.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Mix(OVRHapticsClip)">
            <summary>
            Adds the samples from the specified clip to the ones in the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="T:OVRHapticsClip">
            <summary>
            A PCM buffer of data for a haptics effect.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Count">
            <summary>
            The current number of samples in the clip.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Capacity">
            <summary>
            The maximum number of samples the clip can store.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Samples">
            <summary>
            The raw haptics data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Int32)">
            <summary>
            Creates a clip with the specified capacity.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a clip with the specified data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(OVRHapticsClip,OVRHapticsClip)">
            <summary>
            Creates a clip by mixing the specified clips.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(UnityEngine.AudioClip,System.Int32)">
            <summary>
            Creates a haptics clip from the specified audio clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.WriteSample(System.Byte)">
            <summary>
            Adds the specified sample to the end of the clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.Reset">
            <summary>
            Clears the clip and resets its size to 0.
            </summary>
        </member>
        <member name="T:OVRInput">
            <summary>
            Provides a unified input system for Oculus controllers and gamepads.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Up" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Down" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Left" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Right" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.LTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.RTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Remote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Gamepad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Active" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.All" -->
        <member name="M:OVRInput.#cctor">
            <summary>
            Creates an instance of OVRInput.
            </summary>
        </member>
        <member name="M:OVRInput.Update">
            <summary>
            Updates the internal state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.FixedUpdate">
            <summary>
            Updates the internal physics state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerOrientationTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's orientation is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerPositionTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's position is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerPosition(OVRInput.Controller)">
            <summary>
            Gets the position of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerVelocity(OVRInput.Controller)">
            <summary>
            Gets the linear velocity of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAcceleration(OVRInput.Controller)">
            <summary>
            Gets the linear acceleration of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerRotation(OVRInput.Controller)">
            <summary>
            Gets the rotation of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller)">
            <summary>
            Gets the angular velocity of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularAcceleration(OVRInput.Controller)">
            <summary>
            Gets the angular acceleration of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual button mask with the given controller mask.
            Returns true if any masked button is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw button mask with the given controller mask.
            Returns true if any masked button is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.GetConnectedControllers">
            <summary>
            Returns a mask of all currently connected controller types.
            </summary>
        </member>
        <member name="M:OVRInput.GetActiveController">
            <summary>
            Returns the current active controller type.
            </summary>
        </member>
        <member name="M:OVRInput.SetControllerVibration(System.Single,System.Single,OVRInput.Controller)">
            <summary>
            Activates vibration with the given frequency and amplitude with the given controller mask.
            Ignored on controllers that do not support vibration. Expected values range from 0 to 1.
            </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.AxisGPC">
            <summary> An axis on the gamepad. </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.ButtonGPC">
            <summary> A button on the gamepad. </summary>
        </member>
        <member name="T:OVRManager">
            <summary>
            Configuration data for Oculus virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.instance">
            <summary>
            Gets the singleton instance.
            </summary>
        </member>
        <member name="P:OVRManager.display">
            <summary>
            Gets a reference to the active display.
            </summary>
        </member>
        <member name="P:OVRManager.tracker">
            <summary>
            Gets a reference to the active sensor.
            </summary>
        </member>
        <member name="P:OVRManager.boundary">
            <summary>
            Gets a reference to the active boundary system.
            </summary>
        </member>
        <member name="P:OVRManager.profile">
            <summary>
            Gets the current profile, which contains information about the user's settings and body dimensions.
            </summary>
        </member>
        <member name="E:OVRManager.HMDAcquired">
            <summary>
            Occurs when an HMD attached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDLost">
            <summary>
            Occurs when an HMD detached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDMounted">
            <summary>
            Occurs when an HMD is put on the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.HMDUnmounted">
            <summary>
            Occurs when an HMD is taken off the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusAcquired">
            <summary>
            Occurs when VR Focus is acquired.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusLost">
            <summary>
            Occurs when VR Focus is lost.
            </summary>
        </member>
        <member name="E:OVRManager.AudioOutChanged">
            <summary>
            Occurs when the active Audio Out device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.AudioInChanged">
            <summary>
            Occurs when the active Audio In device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingAcquired">
            <summary>
            Occurs when the sensor gained tracking.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingLost">
            <summary>
            Occurs when the sensor lost tracking.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "E:OVRManager.HSWDismissed" -->
        <member name="P:OVRManager.isHmdPresent">
            <summary>
            If true, a head-mounted display is connected and present.
            </summary>
        </member>
        <member name="P:OVRManager.audioOutId">
            <summary>
            Gets the audio output device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.audioInId">
            <summary>
            Gets the audio input device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.hasVrFocus">
            <summary>
            If true, the app has VR Focus.
            </summary>
        </member>
        <member name="P:OVRManager.isHSWDisplayed">
            <summary>
            If true, then the Oculus health and safety warning (HSW) is currently visible.
            </summary>
        </member>
        <member name="M:OVRManager.DismissHSWDisplay">
            <summary>
            If the HSW has been visible for the necessary amount of time, this will make it disappear.
            </summary>
        </member>
        <member name="P:OVRManager.chromatic">
            <summary>
            If true, chromatic de-aberration will be applied, improving the image at the cost of texture bandwidth.
            </summary>
        </member>
        <member name="P:OVRManager.monoscopic">
            <summary>
            If true, both eyes will see the same image, rendered from the center eye pose, saving performance.
            </summary>
        </member>
        <member name="F:OVRManager.queueAhead">
            <summary>
            If true, distortion rendering work is submitted a quarter-frame early to avoid pipeline stalls and increase CPU-GPU parallelism.
            </summary>
        </member>
        <member name="F:OVRManager.useRecommendedMSAALevel">
            <summary>
            If true, Unity will use the optimal antialiasing level for quality/performance on the current hardware.
            </summary>
        </member>
        <member name="F:OVRManager.enableAdaptiveResolution">
            <summary>
            If true, dynamic resolution will be enabled
            </summary>
        </member>
        <member name="F:OVRManager.maxRenderScale">
            <summary>
            Max RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = ture );
            </summary>
        </member>
        <member name="F:OVRManager.minRenderScale">
            <summary>
            Min RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = ture );
            </summary>
        </member>
        <member name="P:OVRManager.vsyncCount">
            <summary>
            The number of expected display frames per rendered frame.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryLevel" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryTemperature" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryStatus" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.volumeLevel" -->
        <member name="P:OVRManager.cpuLevel">
            <summary>
            Gets or sets the current CPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.gpuLevel">
            <summary>
            Gets or sets the current GPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.isPowerSavingActive">
            <summary>
            If true, the CPU and GPU are currently throttled to save power and/or reduce the temperature.
            </summary>
        </member>
        <member name="P:OVRManager.trackingOriginType">
            <summary>
            Defines the current tracking origin type.
            </summary>
        </member>
        <member name="F:OVRManager.usePositionTracking">
            <summary>
            If true, head tracking will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.useIPDInPositionTracking">
            <summary>
            If true, the distance between the user's eyes will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.resetTrackerOnLoad">
            <summary>
            If true, each scene load will cause the head pose to reset.
            </summary>
        </member>
        <member name="P:OVRManager.isSupportedPlatform">
            <summary>
            True if the current platform supports virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.isUserPresent">
            <summary>
            True if the user is currently wearing the display.
            </summary>
        </member>
        <member name="M:OVRManager.ReturnToLauncher">
            <summary>
            Leaves the application/game and returns to the launcher/dashboard
            </summary>
        </member>
        <member name="T:OVRModeParms">
            <summary>
            Logs when the application enters power save mode and allows you to a low-power CPU/GPU level with a button press.
            </summary>
        </member>
        <member name="F:OVRModeParms.resetButton">
            <summary>
            The gamepad button that will switch the application to CPU level 0 and GPU level 1.
            </summary>
        </member>
        <member name="M:OVRModeParms.Start">
            <summary>
            Invoke power state mode test.
            </summary>
        </member>
        <member name="M:OVRModeParms.Update">
            <summary>
            Change default vr mode parms dynamically.
            </summary>
        </member>
        <member name="M:OVRModeParms.TestPowerStateMode">
            <summary>
            Check current power state mode.
            </summary>
        </member>
        <member name="T:OVRMonoscopic">
            <summary>
            Allows you to toggle monoscopic rendering with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRMonoscopic.toggleButton">
            <summary>
            The gamepad button that will toggle monoscopic rendering.
            </summary>
        </member>
        <member name="M:OVRMonoscopic.Update">
            <summary>
            Check input and toggle monoscopic rendering mode if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVROverlay" -->
        <member name="F:OVROverlay.currentOverlayType">
            <summary>
            Specify overlay's type
            </summary>
        </member>
        <member name="F:OVROverlay.currentOverlayShape">
            <summary>
            Specify overlay's shape
            </summary>
        </member>
        <member name="F:OVROverlay.textures">
            <summary>
            Try to avoid setting texture frequently when app is running, texNativePtr updating is slow since rendering thread synchronization
            Please cache your nativeTexturePtr and use  OverrideOverlayTextureInfo
            </summary>
        </member>
        <member name="M:OVROverlay.OverrideOverlayTextureInfo(UnityEngine.Texture,System.IntPtr,UnityEngine.VR.VRNode)">
            <summary>
            Use this function to set texture and texNativePtr when app is running 
            GetNativeTexturePtr is a slow behavior, the value should be pre-cached 
            </summary>
        </member>
        <member name="T:OVRPlatformMenu">
            <summary>
            Shows the Oculus plaform UI.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.cursorTimer">
            <summary>
            A timer that appears at the gaze cursor before a platform UI transition.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.cursorTimerColor">
            <summary>
            The current color of the cursor timer.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.fixedDepth">
            <summary>
            The distance at which the cursor timer appears.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.keyCode">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Awake">
            <summary>
            Instantiate the cursor timer
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.OnDestroy">
            <summary>
            Destroy the cloned material
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.OnApplicationFocus(System.Boolean)">
            <summary>
            Reset when resuming
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.OnApplicationPause(System.Boolean)">
            <summary>
            Reset when resuming
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.ShowConfirmQuitMenu">
            <summary>
            Show the confirm quit menu
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.ShowGlobalMenu">
            <summary>
            Show the platform UI global menu
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Update">
            <summary>
            Tests for long-press and activates global platform menu when detected.
            as per the Unity integration doc, the back button responds to "mouse 1" button down/up/etc
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.UpdateCursor(System.Single)">
            <summary>
            Update the cursor based on how long the back button is pressed
            </summary>
        </member>
        <member name="T:OVRPlayerController">
            <summary>
            Controls the player's movement in virtual reality.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Acceleration">
            <summary>
            The rate acceleration during movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Damping">
            <summary>
            The rate of damping on movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.BackAndSideDampen">
            <summary>
            The rate of additional damping when moving sideways or backwards.
            </summary>
        </member>
        <member name="F:OVRPlayerController.JumpForce">
            <summary>
            The force applied to the character when jumping.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationAmount">
            <summary>
            The rate of rotation when using a gamepad.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationRatchet">
            <summary>
            The rate of rotation when using the keyboard.
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdResetsY">
            <summary>
            If true, reset the initial yaw of the player controller when the Hmd pose is recentered.
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdRotatesY">
            <summary>
            If true, tracking data from a child OVRCameraRig will update the direction of movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.GravityModifier">
            <summary>
            Modifies the strength of gravity.
            </summary>
        </member>
        <member name="F:OVRPlayerController.useProfileData">
            <summary>
            If true, each OVRPlayerController will use the player's physical height.
            </summary>
        </member>
        <member name="M:OVRPlayerController.UpdateTransform(OVRCameraRig)">
            <summary>
            Invoked by OVRCameraRig's UpdatedAnchors callback. Allows the Hmd rotation to update the facing direction of the player.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Jump">
            <summary>
            Jump! Must be enabled manually.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Stop">
            <summary>
            Stop this instance.
            </summary>
        </member>
        <member name="M:OVRPlayerController.GetMoveScaleMultiplier(System.Single@)">
            <summary>
            Gets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetMoveScaleMultiplier(System.Single)">
            <summary>
            Sets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetRotationScaleMultiplier(System.Single@)">
            <summary>
            Gets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetRotationScaleMultiplier(System.Single)">
            <summary>
            Sets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetSkipMouseRotation(System.Boolean@)">
            <summary>
            Gets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">Allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.SetSkipMouseRotation(System.Boolean)">
            <summary>
            Sets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">If set to <c>true</c> allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.GetHaltUpdateMovement(System.Boolean@)">
            <summary>
            Gets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">Halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.SetHaltUpdateMovement(System.Boolean)">
            <summary>
            Sets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">If set to <c>true</c> halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.ResetOrientation">
            <summary>
            Resets the player look rotation when the device orientation is reset.
            </summary>
        </member>
        <member name="T:OVRProfile">
            <summary>
            Contains information about the user's preferences and body dimensions.
            </summary>
        </member>
        <member name="T:OVRResetOrientation">
            <summary>
            Allows you to reset VR input tracking with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRResetOrientation.resetButton">
            <summary>
            The gamepad button that will reset VR input tracking.
            </summary>
        </member>
        <member name="M:OVRResetOrientation.Update">
            <summary>
            Check input and reset orientation if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <member name="T:OVRRTOverlayConnector">
             <summary>
             Usage: attach this script under your camera object, and point ovrOverlayObj to your overlay owner object.
             Note: 
             1) your camera should use renderTexture 
             2) your need make sure your overlay camera was rendered before you main camera (eg. using camera depth), so the renderTexture will be available before being used.
            
             This is a helper class to setup renderTexture to OVROverlay object
             It did a few things
             1) Clear the renderTarget's border to alpha = 0 for avoiding artifacts on mobile 
             2) Triple buffer the render results before sending to the overlay, which is a requirement for time warping render target
             </summary>
        </member>
        <member name="F:OVRRTOverlayConnector.alphaBorderSizePixels">
            <summary>
            OVROverlay texture required alpha = 0 border for avoiding artifacts
            </summary>
        </member>
        <member name="F:OVRRTOverlayConnector.overlayRTChainSize">
            <summary>
            Triple buffer the render target
            </summary>
        </member>
        <member name="F:OVRRTOverlayConnector.ovrOverlayObj">
            <summary>
            Destination OVROverlay target object
            </summary>
        </member>
        <member name="M:OVRRTOverlayConnector.ConstructRenderTextureChain">
            <summary>
            Triple buffer the textures applying to overlay
            </summary>
        </member>
        <member name="F:OVRRTOverlayConnector.borderCleaned">
            <summary>
            Alpha border cleaning
            </summary>
        </member>
        <member name="M:OVRRTOverlayConnector.OnPostRender">
            <summary>
            Copy camera's render target to triple buffered texture array and send it to OVROverlay object
            </summary>
        </member>
        <member name="T:OVRSceneSampleController">
            <summary>
            Sample that allows you to play with various VR settings. 
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.quitKey">
            <summary>
            The key that quits the application.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.fadeInTexture">
            <summary>
            An optional texture that appears before the menu fades in.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.speedRotationIncrement">
            <summary>
            Controls how quickly the player's speed and rotation change based on input.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.layerName">
            <summary>
            We can set the layer to be anything we want to, this allows
            a specific camera to render it.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateVisionMode">
            <summary>
            Updates the vision mode.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateSpeedAndRotationScaleMultiplier">
            <summary>
            Updates the speed and rotation scale multiplier.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateRecenterPose">
            <summary>
            Recenter pose
            </summary>
        </member>
        <member name="T:OVRScreenFade">
            <summary>
            Fades the screen from black after a new scene is loaded.
            </summary>
        </member>
        <member name="F:OVRScreenFade.fadeTime">
            <summary>
            How long it takes to fade.
            </summary>
        </member>
        <member name="F:OVRScreenFade.fadeColor">
            <summary>
            The initial screen color.
            </summary>
        </member>
        <member name="M:OVRScreenFade.Awake">
            <summary>
            Initialize.
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnEnable">
            <summary>
            Starts the fade in
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnLevelWasLoaded(System.Int32)">
            <summary>
            Starts a fade in when a new level is loaded
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnDestroy">
            <summary>
            Cleans up the fade material
            </summary>
        </member>
        <member name="M:OVRScreenFade.FadeIn">
            <summary>
            Fades alpha from 1.0 to 0.0
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnPostRender">
            <summary>
            Renders the fade overlay when attached to a camera object
            </summary>
        </member>
        <member name="T:OVRTouchpad">
            <summary>
            Interface class to a touchpad.
            </summary>
        </member>
        <member name="T:OVRTouchpad.TouchEvent">
            <summary>
            Touch Type.
            </summary>
        </member>
        <member name="T:OVRTouchpad.TouchArgs">
            <summary>
            Details about a touch event.
            </summary>
        </member>
        <member name="E:OVRTouchpad.TouchHandler">
            <summary>
            Occurs when touched.
            </summary>
        </member>
        <member name="T:OVRTouchpad.TouchState">
            <summary>
            Native Touch State.
            </summary>
        </member>
        <member name="M:OVRTouchpad.Create">
            <summary>
            Add the Touchpad game object into the scene.
            </summary>
        </member>
        <member name="M:OVRTouchpad.HandleInput(OVRTouchpad.TouchState,UnityEngine.Vector2@)">
            <summary>
            Determines if input was a click or swipe and sends message to all prescribers.
            </summary>
        </member>
        <member name="T:OVRTouchpadHelper">
            <summary>
            This singleton class gets created and stays resident in the application. It is used to 
            trap the touchpad values, which get broadcast to any listener on the "Touchpad" channel.
            </summary>
        </member>
        <member name="T:OVRTracker">
            <summary>
            An infrared camera that tracks the position of a head-mounted display.
            </summary>
        </member>
        <member name="T:OVRTracker.Frustum">
            <summary>
            The (symmetric) visible area in front of the sensor.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.nearZ">
            <summary>
            The sensor's minimum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.farZ">
            <summary>
            The sensor's maximum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.fov">
            <summary>
            The sensor's horizontal and vertical fields of view in degrees.
            </summary>
        </member>
        <member name="P:OVRTracker.isPresent">
            <summary>
            If true, a sensor is attached to the system.
            </summary>
        </member>
        <member name="P:OVRTracker.isPositionTracked">
            <summary>
            If true, the sensor is actively tracking the HMD's position. Otherwise the HMD may be temporarily occluded, the system may not support position tracking, etc.
            </summary>
        </member>
        <member name="P:OVRTracker.isEnabled">
            <summary>
            If this is true and a sensor is available, the system will use position tracking when isPositionTracked is also true.
            </summary>
        </member>
        <member name="P:OVRTracker.count">
            <summary>
            Returns the number of sensors currently connected to the system.
            </summary>
        </member>
        <member name="M:OVRTracker.GetFrustum(System.Int32)">
            <summary>
            Gets the sensor's viewing frustum.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPose(System.Int32)">
            <summary>
            Gets the sensor's pose, relative to the head's pose at the time of the last pose recentering.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPoseValid(System.Int32)">
            <summary>
            If true, the pose of the sensor is valid and is ready to be queried.
            </summary>
        </member>
        <member name="T:OVRWaitCursor">
            <summary>
            Rotates this GameObject at a given speed.
            </summary>
        </member>
        <member name="M:OVRWaitCursor.Update">
            <summary>
            Auto rotates the attached cursor.
            </summary>
        </member>
        <member name="T:TBE.PInvAudioEngine">
            <summary>
            Interface for the native functions of the audio engine.
            TBAudioEngine controls all global initialsation/destruction,
            routines and listener parameters.
            All methods are static.
            The AudioEngine must be initialised first and destroyed last.
            </summary>
        </member>
        <member name="M:TBE.PInvAudioEngine.init(System.Single,System.UInt32,TBE.TBEngineFlags)">
            <summary>
            Init the engine by specifying target sample rate and buffer size.
            This method must be called first before any other engine component is initialised.
            It is not guaranteed that the target device/OS will accept these settings.
            The final values can be queried from getSampleRate and getBufferSize
            </summary>
            <param name="in_fSampleRate">Target sample rate in Hz</param>
            <param name="in_uBufferSize">Target buffer size in samples</param>
            <returns>TB_SUCCESS if initialisation is successful, or corresponding error message</returns>
        </member>
        <member name="M:TBE.PInvAudioEngine.isInitialised">
            <summary>
            Returns true if the engine is initialised, else false
            </summary>
            <returns><c>true</c>If the engine is initialised, else false <c>false</c> otherwise.</returns>
        </member>
        <member name="M:TBE.PInvAudioEngine.destroy">
            <summary>
            Destroy all resources. Must be called last, after all 
            other engine components are destroyed
            </summary>
        </member>
        <member name="M:TBE.PInvAudioEngine.start">
            <summary>
            Start audio processing (controls global playback of all objects)
            This can be useful for starting and pausing all activity on the audio thread
            (such as when the app is in the background)
            </summary>
        </member>
        <member name="M:TBE.PInvAudioEngine.pause">
            <summary>
            Pause audio processing (controls global playback of all objects)
            This can be useful for starting and pausing all activity on the audio thread
            such as when the app is in the background)
            </summary>
        </member>
        <member name="M:TBE.PInvAudioEngine.setListenerOrientation(TBE.TBVector3,TBE.TBVector3)">
            <summary>
            Set the orientation of the listener through direction vectors
            </summary>
            <param name="ForwardVector">Forward vector of the listener</param>
            <param name="UpVector">Up vector of the listener</param>
        </member>
        <member name="M:TBE.PInvAudioEngine.getSampleRate">
            <summary>
            Returns the sample rate of the engine in Hz.
            </summary>
            <returns>The sample rate in Hz.</returns>
        </member>
        <member name="M:TBE.PInvAudioEngine.getBufferSize">
            <summary>
            Retuns the buffer size of the engine in samples.
            </summary>
            <returns>The buffer size in samples.</returns>
        </member>
        <member name="M:TBE.PInvAudioEngine.getAudioMix(System.Single[],System.Int32)">
            <summary>
            Returns the audio mix -- CAUTION use this only if TBEngineFlags in the init() method is set to INIT_NO_SINK
            </summary>
            <param name="in_Buffer">In_ buffer.</param>
            <param name="in_iNumOfSamples">In_i number of samples.</param>
        </member>
        <member name="T:TBE.PInvSpatDecoder">
            <summary>
            Interface for native functions of TBSpatDecoder
            </summary>
        </member>
        <member name="T:TBE.TBEngineDestroy">
            <summary>
            Destroys the engine when the parent object of this component is destroyed
            </summary>
        </member>
        <member name="T:TBE.TBEngineInitialise">
            <summary>
            Initialises the audio engine on Awake
            </summary>
        </member>
        <member name="T:TBE.TBEngineListener">
            <summary>
            Updates the listener's orientation in the engine. Must be placed on the main camera.
            </summary>
        </member>
        <member name="T:TBE.TBSpatDecoder">
            <summary>
            Decodes and plays back assets created
            with the desktop authoring tool. The mix
            is recreated in full 3D
            </summary>
        </member>
        <member name="M:TBE.TBSpatDecoder.loadAssetFromApp(System.String)">
            <summary>
            Load an asset of type .tba, created by desktop authoring tools
            The file must be placed in Assets/StreamingAssets and will automatically
            be picked up the engine.
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
            <param name="AssetName">Name of the asset, including extension, placed in the 'StreamingAssets' folder.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.loadAssetFromPath(System.String)">
            <summary>
            Load an asset with absolute path, created by desktop authoring tools
            The file can be placed anywhere on the system.
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
            <param name="AssetName">Name of the asset with absolute ath, including extension.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.loadChunkAsAsset(System.String,System.Int64,System.Int64)">
            <summary>
            Load a chunk of data as an asset. This is useful in cases where multiple assets might be combined in a "store" zip file or a binary blob.
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
            <param name="AbsoluteFileNameAndPath">Absolute file name and path.</param>
            <param name="offsetInBytes">Offset in bytes, from start of file.</param>
            <param name="lengthInBytes">Length of asset in bytes.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.play">
            <summary>
            Playback the asset
            Resumes playback if paused. Starts playback
            from the beginning if stopped.
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.stop">
            <summary>
            Stop playback
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.pause">
            <summary>
            Pause playback
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error message.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.enableFocus(System.Boolean,System.Boolean)">
            <summary>
            Enable mix focus. This gets a specfied area of the mix to be more audible than surrounding areas, by reducing the
            amplitude of the area that isn't in focus.
            The focus area is shaped as a cosine bump.
            </summary>
            <param name="enableFocus">If set to <c>true</c> enables focus.</param>
            <param name="followListener">If set to <c>true</c>, the focus area follows the listener's gaze.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.setFocusProperties(System.Single,System.Single)">
            <summary>
            Set the properties of the focus effect. This will be audible only if enableFocus in
            enableFocus(..) is set to true.
            </summary>
            <param name="offFocusLevel">The level of the area that isn't in focus. A clamped ranged between 0 and 1. 1 is no focus. 0 is maximum focus (the
                                    off focus area is reduced by 14dB). Default = 1. </param>
            <param name="focusWidth">The focus area specified in degrees. Clamped to a range of 40 to 120 degrees. Default = 90 degrees.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.setFocusOrientationQuat(UnityEngine.Quaternion)">
            <summary>
            Set the orientation of the focus area as a quaternion. This orientation is from the perspective
            of the listener and comes into effect only if followListener in enableFocus(..) is set to false.
            </summary>
            <param name="focusQuat">Orientation of the focus area as a quaternion.</param>
        </member>
        <member name="M:TBE.TBSpatDecoder.getTimeInSamples">
            <summary>
            Returns the elapsed time, in samples, of the currently loaded asset
            </summary>
            <returns>Elapsed time in samples.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.getAssetDurationInSamples">
            <summary>
            Returns the duration of the asset (if loaded) in samples.
            </summary>
            <returns>The duration of the asset in samples.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.getAssetDurationInMs">
            <summary>
            Returns the duration of the asset (if loaded) in milliseconds
            </summary>
            <returns>The duration of the asset in milliseconds.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.getTimeInMs">
            <summary>
            Returns the elapsed time, in milliseconds, of the currently loaded asset
            </summary>
            <returns>Elapsed time in ms.</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.setTimeInSamples(System.Int32)">
            <summary>
            Set the playback position, in samples, of the currently loaded asset
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.setTimeInMs(System.Single)">
            <summary>
            Set the playback position, in milliseconds, of the currently loaded asset
            </summary>
            <returns>TB_SUCCESS if successful or corresponding error</returns>
        </member>
        <member name="M:TBE.TBSpatDecoder.setExternalClockInMs(System.Single)">
            <summary>
            If syncMode is set to TB_SYNC_EXTERNAL, playback can be
            synchronised to an external time reference in milliseconds
            </summary>
            <param name="externalClockInMs">External time reference in milliseconds</param>
        </member>
        <member name="P:TBE.TBSpatDecoder.streamingAsset">
            <summary>
            Gets or sets the streaming asset name with extension, placed in the 'StreamingAssets' folder.
            </summary>
            <value>The streaming asset name with extension</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.playTriggerType">
            <summary>
            Gets or sets the playback trigger
            </summary>
            <value>The type of trigger.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.loadTriggerType">
            <summary>
            Gets or sets the load trigger
            </summary>
            <value>The type of the load trigger.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.playState">
            <summary>
            Gets the playback state.
            </summary>
            <value>TB_STATE_PLAYING, TB_STATE_PAUSED, TB_STATE_STOPPED or TB_STATE_INVALID</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.syncMode">
            <summary>
            Gets or sets the sync mode.
            If set to external (TB_SYNC_EXTERNAL), playback is controlled by an external clock
            using the setExternalClockInMs method. If set to internal (default), playback is synchronised
            to the audio hardware
            </summary>
            <value>The sync mode.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.freewheelTimeMs">
            <summary>
            Set/get how often the synchroniser syncs with the external clock in milliseconds.
            Setting this to a larger value can help overcome drop outs or slow update times from the clock source
            Default recommended value: 200ms.
            This only has an effect if syncMode is set to TB_SYNC_EXTERNAL
            </summary>
            <value>How often (in milliseconds) the synchroniser syncs with the external clock. Default: 200ms</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.volumeInDecibels">
            <summary>
            Gets or sets the volume in decibels.
            </summary>
            <value>The volume in decibels.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.volume">
            <summary>
            Gets or set the linear amplitude.
            </summary>
            <value>The linear amplitude.</value>
        </member>
        <!-- Badly formed XML comment ignored for member "P:TBE.TBSpatDecoder.focus" -->
        <member name="P:TBE.TBSpatDecoder.followListener">
            <summary>
            The focus area follows the listener's gaze.
            </summary>
            <value name="followListener">If set to <c>true</c>, the focus area follows the listener's gaze.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.offFocusLevel">
            <summary>
            The level of the area that isn't in focus. A clamped ranged between 0 and 1. 1 is no focus. 0 is maximum focus (the
                                    off focus area is reduced by 14dB). Default = 1. 
            </summary>
            <value>The off focus level.</value>
        </member>
        <member name="P:TBE.TBSpatDecoder.focusWidth">
            <summary>
            The focus area specified in degrees. Clamped to a range of 40 to 120 degrees. Default = 90 degrees.
            </summary>
            <value>The width of the focus area.</value>
        </member>
        <member name="T:TBE.TBAssetLocation">
            For specifying if the asset must be found from the app bundle
            or if the asset name includes the absolute path
        </member>
        <member name="F:TBE.TBAssetLocation.ASSET_ABSOLUTE_PATH">
            The asset must be found from the app bundle (within the app resources on iOS, 'assets' folder on Android)
        </member>
        <member name="T:Pose3D">
            @cond
            Encapsulates a rotation and a translation.  This is a convenience class that allows
            construction and value access either by Matrix4x4 or Quaternion + Vector3 types.
        </member>
        <member name="F:Pose3D.flipZ">
            Right-handed to left-handed matrix converter (and vice versa).
        </member>
        <member name="P:Pose3D.Position">
            The translation component of the pose.
        </member>
        <member name="P:Pose3D.Orientation">
            The rotation component of the pose.
        </member>
        <member name="P:Pose3D.Matrix">
            The pose as a matrix in Unity gameobject convention (left-handed).
        </member>
        <member name="P:Pose3D.RightHandedMatrix">
            The pose as a matrix in right-handed coordinates.
        </member>
        <member name="M:Pose3D.#ctor">
            Default constructor.
            Initializes position to the origin and orientation to the identity rotation.
        </member>
        <member name="M:Pose3D.#ctor(UnityEngine.Vector3,UnityEngine.Quaternion)">
            Constructor that takes a Vector3 and a Quaternion.
        </member>
        <member name="M:Pose3D.#ctor(UnityEngine.Matrix4x4)">
            Constructor that takes a Matrix4x4.
        </member>
        <member name="T:MutablePose3D">
            @endcond
            @cond
            Mutable version of Pose3D.
        </member>
        <member name="M:MutablePose3D.Set(UnityEngine.Vector3,UnityEngine.Quaternion)">
            Sets the position and orientation from a Vector3 + Quaternion.
        </member>
        <member name="M:MutablePose3D.Set(UnityEngine.Matrix4x4)">
            Sets the position and orientation from a Matrix4x4.
        </member>
        <member name="M:MutablePose3D.SetRightHanded(UnityEngine.Matrix4x4)">
            Sets the position and orientation from a right-handed Matrix4x4.
        </member>
        <member name="T:StereoController">
             Controls a pair of GvrEye objects that will render the stereo view
             of the camera this script is attached to.
            
             This script must be added to any camera that should render stereo when the app
             is in VR Mode.  This includes picture-in-picture windows, whether their contents
             are in stereo or not: the window itself must be twinned for stereo, regardless.
            
             For each frame, StereoController decides whether to render via the camera it
             is attached to (the _mono_ camera) or the stereo eyes that it controls (see
             GvrEye). You control this  decision for all cameras at once by setting
             the value of GvrViewer#VRModeEnabled.
            
             For technical reasons, the mono camera remains enabled for the initial portion of
             the frame.  It is disabled only when rendering begins in `OnPreCull()`, and is
             reenabled again at the end of the frame.  This allows 3rd party scripts that use
             `Camera.main`, for example, to refer the the mono camera even when VR Mode is
             enabled.
            
             At startup the script ensures it has a full stereo rig, which consists of two
             child cameras with GvrEye scripts attached, and a GvrHead script
             somewhere in the hierarchy of parents and children for head tracking.  The rig
             is created if necessary, the GvrHead being attached to the controller
             itself.  The child camera settings are then cloned or updated from the mono
             camera.
            
             It is permissible for a StereoController to contain another StereoController
             as a child.  In this case, a GvrEye is controlled by its closest
             StereoController parent.
            
             The Inspector panel for this script includes a button _Update Stereo Cameras_.
             This performs the same action as described above for startup, but in the Editor.
             Use this to generate the rig if you intend to customize it.  This action is also
             available via _Component -> GVR -> Update Stereo Cameras_ in the Editor’s
             main menu, and in the context menu for the `Camera` component.
        </member>
        <member name="F:StereoController.keepStereoUpdated">
            When enabled, UpdateStereoValues() is called every frame to keep the stereo cameras
            completely synchronized with both the mono camera and the device profile.  When
            disabled, you must call UpdateStereoValues() whenever you make a change to the mono
            camera that should be mirrored to the stereo cameras.  Changes to the device profile
            are handled automatically.  It is better for performance to leave this option disabled
            whenever possible.  Good use cases for enabling it are when animating values on the
            mono camera (like background color), or during development to debug camera synchronization
            issues.
        </member>
        <member name="F:StereoController.stereoMultiplier">
            Adjusts the level of stereopsis for this stereo rig.
            @note This parameter is not the virtual size of the head -- use a scale
            on the head game object for that.  Instead, it is a control on eye vergence,
            or rather, how cross-eyed or not the stereo rig is.  Set to 0 to turn
            off stereo in this rig independently of any others.
        </member>
        <member name="F:StereoController.matchMonoFOV">
             The stereo cameras by default use the actual optical FOV of the VR device,
             because otherwise the match between head motion and scene motion is broken, which
             impacts the virtual reality effect.  However, in some cases it is desirable to
             adjust the FOV anyway, for special effects or artistic reasons.  But in no case
             should the FOV be allowed to remain very different from the true optical FOV for
             very long, or users will experience discomfort.
            
             This value determines how much to match the mono camera's field of view.  This is
             a fraction: 0 means no matching, 1 means full matching, and values in between are
             compromises.  Reasons for not matching 100% would include preserving some VR-ness,
             and that due to the lens distortion the edges of the view are not as easily seen as
             when the phone is not in VR-mode.
            
             Another use for this variable is to preserve scene composition against differences
             in the optical FOV of various viewer models.  In all cases, this value simply
             lets the mono camera have some control over the scene in VR mode, like it does in
             non-VR mode.
        </member>
        <member name="F:StereoController.matchByZoom">
             Determines the method by which the stereo cameras' FOVs are matched to the mono
             camera's FOV (assuming #matchMonoFOV is not 0).  The default is to move the stereo
             cameras (#matchByZoom = 0), with the option to instead do a simple camera zoom
             (#matchByZoom = 1).  In-between values yield a mix of the two behaviors.
            
             It is not recommended to use simple zooming for typical scene composition, as it
             conflicts with the VR need to match the user's head motion with the corresponding
             scene motion.  This should be reserved for special effects such as when the player
             views the scene through a telescope or other magnifier (and thus the player knows
             that VR is going to be affected), or similar situations.
            
             @note Matching by moving the eyes requires that the #centerOfInterest object
             be non-null, or there will be no effect.
        </member>
        <member name="F:StereoController.centerOfInterest">
             Matching the mono camera's field of view in stereo by moving the eyes requires
             a designated "center of interest".  This is either a point in space (an empty
             gameobject) you place in the scene as a sort of "3D cursor", or an actual scene
             entity which the player is likely to be focussed on.
            
             The FOV adjustment is done by moving the eyes toward or away from the COI
             so that it appears to have the same size on screen as it would in the mono
             camera.  This is disabled if the COI is null.
        </member>
        <member name="F:StereoController.radiusOfInterest">
            The #centerOfInterest is generally meant to be just a point in space, like a 3D cursor.
            Occasionally, you will want it to be an actual object with size.  Set this
            to the approximate radius of the object to help the FOV-matching code
            compensate for the object's horizon when it is close to the camera.
        </member>
        <member name="F:StereoController.checkStereoComfort">
            If true, check that the #centerOfInterest is between the min and max comfortable
            viewing distances (see GvrViewer.cs), or else adjust the stereo multiplier to
            compensate.  If the COI has a radius, then the near side is checked.  COI must
            be non-null for this setting to have any effect.
        </member>
        <member name="F:StereoController.stereoAdjustSmoothing">
            Smoothes the changes to the stereo camera FOV and position based on #centerOfInterest
            and #checkStereoComfort.
        </member>
        <member name="F:StereoController.screenParallax">
            For picture-in-picture cameras that don't fill the entire screen,
            set the virtual depth of the window itself.  A value of 0 means
            zero parallax, which is fairly close.  A value of 1 means "full"
            parallax, which is equal to the interpupillary distance and equates
            to an infinitely distant window.  This does not affect the actual
            screen size of the the window (in pixels), only the stereo separation
            of the left and right images.
        </member>
        <member name="F:StereoController.stereoPaddingX">
            For picture-in-picture cameras, move the window away from the edges
            in VR Mode to make it easier to see.  The optics of HMDs make the screen
            edges hard to see sometimes, so you can use this to keep the PIP visible
            whether in VR Mode or not.  The x value is the fraction of the screen along
            either side to pad.
        </member>
        <member name="F:StereoController.stereoPaddingY">
            For picture-in-picture cameras, move the window away from the edges
            in VR Mode to make it easier to see.  The optics of HMDs make the screen
            edges hard to see sometimes, so you can use this to keep the PIP visible
            whether in VR Mode or not.  The y value is for the top and bottom of the screen to pad.
        </member>
        <member name="P:StereoController.Eyes">
            Returns an array of stereo cameras that are controlled by this instance of
            the script.
            @note This array is cached for speedier access.  Call
            InvalidateEyes if it is ever necessary to reset the cache.
        </member>
        <member name="P:StereoController.Head">
            Returns the nearest GvrHead that affects our eyes.
            @note Cached for speed.  Call InvalidateEyes to clear the cache.
        </member>
        <member name="M:StereoController.InvalidateEyes">
            Clear the cached array of GvrEye children, as well as the GvrHead that controls
            their gaze.
            @note Be sure to call this if you programmatically change the set of GvrEye children
            managed by this StereoController.
        </member>
        <member name="M:StereoController.AddStereoRig">
            Helper routine for creation of a stereo rig.  Used by the
            custom editor for this class, or to build the rig at runtime.
        </member>
        <member name="M:StereoController.UpdateStereoValues">
            Updates the stereo cameras from the mono camera every frame.  This includes all Camera
            component values such as background color, culling mask, viewport rect, and so on.  Also,
            it includes updating the viewport rect and projection matrix for side-by-side stereo, plus
            applying any adjustments for center of interest and stereo comfort.
        </member>
        <member name="M:StereoController.ComputeStereoEyePosition(GvrViewer.Eye,System.Single,System.Single)">
            Compute the position of one of the stereo eye cameras.  Accounts for both
            FOV matching and stereo comfort, if those features are enabled.  The input is
            the [1,1] entry of the eye camera's projection matrix, representing the vertical
            field of view, and the overall scale being applied to the Z axis.  Returns the
            position of the stereo eye camera in local coordinates.
        </member>
        <member name="T:StereoRenderEffect">
            @cond
        </member>
    </members>
</doc>
